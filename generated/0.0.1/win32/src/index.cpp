/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY n-wgpu v0.0.1
 */
#include "index.h"

#if defined(DAWN_ENABLE_BACKEND_D3D12)
    static dawn_native::BackendType backendType = dawn_native::BackendType::D3D12;
#elif defined(DAWN_ENABLE_BACKEND_METAL)
    static dawn_native::BackendType backendType = dawn_native::BackendType::Metal;
#elif defined(DAWN_ENABLE_BACKEND_OPENGL)
    static dawn_native::BackendType backendType = dawn_native::BackendType::OpenGL;
#elif defined(DAWN_ENABLE_BACKEND_VULKAN)
    static dawn_native::BackendType backendType = dawn_native::BackendType::Vulkan;
#else
    #error
#endif

DawnDevice device;
DawnQueue queue;
DawnSwapChain swapchain;
DawnRenderPipeline pipeline;

DawnTextureFormat swapChainFormat;

GLFWwindow* window;

static std::unique_ptr<dawn_native::Instance> instance;

void onGLFWError(int code, const char* message) {
  std::cout << "GLFW error: " << code << " - " << message << std::endl;
}

dawn::Device CreateCppDawnDevice() {
  glfwSetErrorCallback(onGLFWError);

  if (!glfwInit()) return dawn::Device();

  if (backendType == dawn_native::BackendType::OpenGL) {
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 4);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
  } else {
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
  }

  window = glfwCreateWindow(640, 480, "Dawn window", nullptr, nullptr);
  if (!window) return dawn::Device();

  instance = std::make_unique<dawn_native::Instance>();

  if (backendType == dawn_native::BackendType::OpenGL) {
#if defined(DAWN_ENABLE_BACKEND_OPENGL)
  glfwMakeContextCurrent(window);
  dawn_native::opengl::AdapterDiscoveryOptions adapterOptions;
  adapterOptions.getProc = reinterpret_cast<void* (*)(const char*)>(glfwGetProcAddress);
  instance->DiscoverAdapters(&adapterOptions);
#endif
  } else {
    instance->DiscoverDefaultAdapters();
  }

  bool lol = instance->IsBackendValidationEnabled();
  dawn_platform::Platform* platform = instance->GetPlatform();

  std::vector<dawn_native::Adapter> adapters = instance->GetAdapters();
  dawn_native::Adapter backendAdapter;

  DawnDevice backendDevice = backendAdapter.CreateDevice();
  DawnProcTable backendProcs = dawn_native::GetProcs();

  return dawn::Device();
}

static Napi::Value getAddressFromArrayBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (!(info[0].IsArrayBuffer())) {
    Napi::TypeError::New(env, "Argument 1 must be of type 'ArrayBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  Napi::ArrayBuffer buffer = info[0].As<Napi::ArrayBuffer>();
  int64_t addr = reinterpret_cast<int64_t>(buffer.Data());
  return Napi::BigInt::New(env, addr);
};

Napi::Object Init(Napi::Env env, Napi::Object exports) {
  exports["getAddressFromArrayBuffer"] = Napi::Function::New(env, getAddressFromArrayBuffer, "getAddressFromArrayBuffer");

  device = CreateCppDawnDevice().Release();
  //queue = dawnDeviceCreateQueue(device);

  return exports;
}

NODE_API_MODULE(addon, Init)
