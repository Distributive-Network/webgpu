/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY webgpu v0.0.2
 */
#include "DescriptorDecoder.h"

#include "GPUDevice.h"
#include "GPUAdapter.h"
#include "GPUQueue.h"
#include "GPUFence.h"
#include "GPUBuffer.h"
#include "GPUTexture.h"
#include "GPUTextureView.h"
#include "GPUSampler.h"
#include "GPUBindGroupLayout.h"
#include "GPUPipelineLayout.h"
#include "GPUBindGroup.h"
#include "GPUShaderModule.h"
#include "GPURenderPipeline.h"

#include <unordered_map>


static std::unordered_map<std::string, uint32_t> GPUAddressModeMap = {
  { "repeat", 0 },
  { "mirror-repeat", 1 },
  { "clamp-to-edge", 2 },
};

static std::unordered_map<std::string, uint32_t> GPUBindingTypeMap = {
  { "uniform-buffer", 0 },
  { "storage-buffer", 1 },
  { "readonly-storage-buffer", 2 },
  { "sampler", 3 },
  { "sampled-texture", 4 },
  { "storage-texture", 5 },
};

static std::unordered_map<std::string, uint32_t> GPUBlendFactorMap = {
  { "zero", 0 },
  { "one", 1 },
  { "src-color", 2 },
  { "one-minus-src-color", 3 },
  { "src-alpha", 4 },
  { "one-minus-src-alpha", 5 },
  { "dst-color", 6 },
  { "one-minus-dst-color", 7 },
  { "dst-alpha", 8 },
  { "one-minus-dst-alpha", 9 },
  { "src-alpha-saturated", 10 },
  { "blend-color", 11 },
  { "one-minus-blend-color", 12 },
};

static std::unordered_map<std::string, uint32_t> GPUBlendOperationMap = {
  { "add", 0 },
  { "subtract", 1 },
  { "reverse-subtract", 2 },
  { "min", 3 },
  { "max", 4 },
};

static std::unordered_map<std::string, uint32_t> GPUBufferMapAsyncStatusMap = {
  { "success", 0 },
  { "error", 1 },
  { "unknown", 2 },
  { "device-lost", 3 },
};

static std::unordered_map<std::string, uint32_t> GPUCompareFunctionMap = {
  { "never", 0 },
  { "less", 1 },
  { "less-equal", 2 },
  { "greater", 3 },
  { "greater-equal", 4 },
  { "equal", 5 },
  { "not-equal", 6 },
  { "always", 7 },
};

static std::unordered_map<std::string, uint32_t> GPUCullModeMap = {
  { "none", 0 },
  { "front", 1 },
  { "back", 2 },
};

static std::unordered_map<std::string, uint32_t> GPUErrorFilterMap = {
  { "none", 0 },
  { "validation", 1 },
  { "out-of-memory", 2 },
};

static std::unordered_map<std::string, uint32_t> GPUErrorTypeMap = {
  { "no-error", 0 },
  { "validation", 1 },
  { "out-of-memory", 2 },
  { "unknown", 3 },
  { "device-lost", 4 },
};

static std::unordered_map<std::string, uint32_t> GPUFenceCompletionStatusMap = {
  { "success", 0 },
  { "error", 1 },
  { "unknown", 2 },
  { "device-lost", 3 },
};

static std::unordered_map<std::string, uint32_t> GPUFilterModeMap = {
  { "nearest", 0 },
  { "linear", 1 },
};

static std::unordered_map<std::string, uint32_t> GPUFrontFaceMap = {
  { "ccw", 0 },
  { "cw", 1 },
};

static std::unordered_map<std::string, uint32_t> GPUIndexFormatMap = {
  { "uint16", 0 },
  { "uint32", 1 },
};

static std::unordered_map<std::string, uint32_t> GPUInputStepModeMap = {
  { "vertex", 0 },
  { "instance", 1 },
};

static std::unordered_map<std::string, uint32_t> GPULoadOpMap = {
  { "clear", 0 },
  { "load", 1 },
};

static std::unordered_map<std::string, uint32_t> GPUStoreOpMap = {
  { "store", 0 },
};

static std::unordered_map<std::string, uint32_t> GPUPrimitiveTopologyMap = {
  { "point-list", 0 },
  { "line-list", 1 },
  { "line-strip", 2 },
  { "triangle-list", 3 },
  { "triangle-strip", 4 },
};

static std::unordered_map<std::string, uint32_t> GPUStencilOperationMap = {
  { "keep", 0 },
  { "zero", 1 },
  { "replace", 2 },
  { "invert", 3 },
  { "increment-clamp", 4 },
  { "decrement-clamp", 5 },
  { "increment-wrap", 6 },
  { "decrement-wrap", 7 },
};

static std::unordered_map<std::string, uint32_t> GPUTextureAspectMap = {
  { "all", 0 },
  { "stencil-only", 1 },
  { "depth-only", 2 },
};

static std::unordered_map<std::string, uint32_t> GPUTextureComponentTypeMap = {
  { "float", 0 },
  { "sint", 1 },
  { "uint", 2 },
};

static std::unordered_map<std::string, uint32_t> GPUTextureDimensionMap = {
  { "1d", 0 },
  { "2d", 1 },
  { "3d", 2 },
};

static std::unordered_map<std::string, uint32_t> GPUTextureFormatMap = {
  { "undefined", 0 },
  { "r8unorm", 1 },
  { "r8snorm", 2 },
  { "r8uint", 3 },
  { "r8sint", 4 },
  { "r16uint", 5 },
  { "r16sint", 6 },
  { "r16float", 7 },
  { "rg8unorm", 8 },
  { "rg8snorm", 9 },
  { "rg8uint", 10 },
  { "rg8sint", 11 },
  { "r32float", 12 },
  { "r32uint", 13 },
  { "r32sint", 14 },
  { "rg16uint", 15 },
  { "rg16sint", 16 },
  { "rg16float", 17 },
  { "rgba8unorm", 18 },
  { "rgba8unorm-srgb", 19 },
  { "rgba8snorm", 20 },
  { "rgba8uint", 21 },
  { "rgba8sint", 22 },
  { "bgra8unorm", 23 },
  { "bgra8unorm-srgb", 24 },
  { "rgb10a2unorm", 25 },
  { "rg11b10float", 26 },
  { "rg32float", 27 },
  { "rg32uint", 28 },
  { "rg32sint", 29 },
  { "rgba16uint", 30 },
  { "rgba16sint", 31 },
  { "rgba16float", 32 },
  { "rgba32float", 33 },
  { "rgba32uint", 34 },
  { "rgba32sint", 35 },
  { "depth32float", 36 },
  { "depth24plus", 37 },
  { "depth24plus-stencil8", 38 },
  { "bc1rgba-unorm", 39 },
  { "bc1rgba-unorm-srgb", 40 },
  { "bc2rgba-unorm", 41 },
  { "bc2rgba-unorm-srgb", 42 },
  { "bc3rgba-unorm", 43 },
  { "bc3rgba-unorm-srgb", 44 },
  { "bc4r-unorm", 45 },
  { "bc4r-snorm", 46 },
  { "bc5rg-unorm", 47 },
  { "bc5rg-snorm", 48 },
  { "bc6hrgb-ufloat", 49 },
  { "bc6hrgb-sfloat", 50 },
  { "bc7rgba-unorm", 51 },
  { "bc7rgba-unorm-srgb", 52 },
};

static std::unordered_map<std::string, uint32_t> GPUTextureViewDimensionMap = {
  { "undefined", 0 },
  { "1d", 1 },
  { "2d", 2 },
  { "2darray", 3 },
  { "cube", 4 },
  { "cube-array", 5 },
  { "3d", 6 },
};

static std::unordered_map<std::string, uint32_t> GPUVertexFormatMap = {
  { "uchar2", 0 },
  { "uchar4", 1 },
  { "char2", 2 },
  { "char4", 3 },
  { "uchar2norm", 4 },
  { "uchar4norm", 5 },
  { "char2norm", 6 },
  { "char4norm", 7 },
  { "ushort2", 8 },
  { "ushort4", 9 },
  { "short2", 10 },
  { "short4", 11 },
  { "ushort2norm", 12 },
  { "ushort4norm", 13 },
  { "short2norm", 14 },
  { "short4norm", 15 },
  { "half2", 16 },
  { "half4", 17 },
  { "float", 18 },
  { "float2", 19 },
  { "float3", 20 },
  { "float4", 21 },
  { "uint", 22 },
  { "uint2", 23 },
  { "uint3", 24 },
  { "uint4", 25 },
  { "int", 26 },
  { "int2", 27 },
  { "int3", 28 },
  { "int4", 29 },
};


namespace DescriptorDecoder {
  
  uint32_t GPUAddressMode(std::string name) {
    return GPUAddressModeMap[name];
  };
  std::string GPUAddressMode(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUAddressModeMap),
      std::end(GPUAddressModeMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUAddressModeMap)) return "";

    return it->first;
  };
  
  uint32_t GPUBindingType(std::string name) {
    return GPUBindingTypeMap[name];
  };
  std::string GPUBindingType(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUBindingTypeMap),
      std::end(GPUBindingTypeMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUBindingTypeMap)) return "";

    return it->first;
  };
  
  uint32_t GPUBlendFactor(std::string name) {
    return GPUBlendFactorMap[name];
  };
  std::string GPUBlendFactor(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUBlendFactorMap),
      std::end(GPUBlendFactorMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUBlendFactorMap)) return "";

    return it->first;
  };
  
  uint32_t GPUBlendOperation(std::string name) {
    return GPUBlendOperationMap[name];
  };
  std::string GPUBlendOperation(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUBlendOperationMap),
      std::end(GPUBlendOperationMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUBlendOperationMap)) return "";

    return it->first;
  };
  
  uint32_t GPUBufferMapAsyncStatus(std::string name) {
    return GPUBufferMapAsyncStatusMap[name];
  };
  std::string GPUBufferMapAsyncStatus(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUBufferMapAsyncStatusMap),
      std::end(GPUBufferMapAsyncStatusMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUBufferMapAsyncStatusMap)) return "";

    return it->first;
  };
  
  uint32_t GPUCompareFunction(std::string name) {
    return GPUCompareFunctionMap[name];
  };
  std::string GPUCompareFunction(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUCompareFunctionMap),
      std::end(GPUCompareFunctionMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUCompareFunctionMap)) return "";

    return it->first;
  };
  
  uint32_t GPUCullMode(std::string name) {
    return GPUCullModeMap[name];
  };
  std::string GPUCullMode(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUCullModeMap),
      std::end(GPUCullModeMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUCullModeMap)) return "";

    return it->first;
  };
  
  uint32_t GPUErrorFilter(std::string name) {
    return GPUErrorFilterMap[name];
  };
  std::string GPUErrorFilter(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUErrorFilterMap),
      std::end(GPUErrorFilterMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUErrorFilterMap)) return "";

    return it->first;
  };
  
  uint32_t GPUErrorType(std::string name) {
    return GPUErrorTypeMap[name];
  };
  std::string GPUErrorType(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUErrorTypeMap),
      std::end(GPUErrorTypeMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUErrorTypeMap)) return "";

    return it->first;
  };
  
  uint32_t GPUFenceCompletionStatus(std::string name) {
    return GPUFenceCompletionStatusMap[name];
  };
  std::string GPUFenceCompletionStatus(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUFenceCompletionStatusMap),
      std::end(GPUFenceCompletionStatusMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUFenceCompletionStatusMap)) return "";

    return it->first;
  };
  
  uint32_t GPUFilterMode(std::string name) {
    return GPUFilterModeMap[name];
  };
  std::string GPUFilterMode(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUFilterModeMap),
      std::end(GPUFilterModeMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUFilterModeMap)) return "";

    return it->first;
  };
  
  uint32_t GPUFrontFace(std::string name) {
    return GPUFrontFaceMap[name];
  };
  std::string GPUFrontFace(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUFrontFaceMap),
      std::end(GPUFrontFaceMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUFrontFaceMap)) return "";

    return it->first;
  };
  
  uint32_t GPUIndexFormat(std::string name) {
    return GPUIndexFormatMap[name];
  };
  std::string GPUIndexFormat(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUIndexFormatMap),
      std::end(GPUIndexFormatMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUIndexFormatMap)) return "";

    return it->first;
  };
  
  uint32_t GPUInputStepMode(std::string name) {
    return GPUInputStepModeMap[name];
  };
  std::string GPUInputStepMode(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUInputStepModeMap),
      std::end(GPUInputStepModeMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUInputStepModeMap)) return "";

    return it->first;
  };
  
  uint32_t GPULoadOp(std::string name) {
    return GPULoadOpMap[name];
  };
  std::string GPULoadOp(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPULoadOpMap),
      std::end(GPULoadOpMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPULoadOpMap)) return "";

    return it->first;
  };
  
  uint32_t GPUStoreOp(std::string name) {
    return GPUStoreOpMap[name];
  };
  std::string GPUStoreOp(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUStoreOpMap),
      std::end(GPUStoreOpMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUStoreOpMap)) return "";

    return it->first;
  };
  
  uint32_t GPUPrimitiveTopology(std::string name) {
    return GPUPrimitiveTopologyMap[name];
  };
  std::string GPUPrimitiveTopology(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUPrimitiveTopologyMap),
      std::end(GPUPrimitiveTopologyMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUPrimitiveTopologyMap)) return "";

    return it->first;
  };
  
  uint32_t GPUStencilOperation(std::string name) {
    return GPUStencilOperationMap[name];
  };
  std::string GPUStencilOperation(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUStencilOperationMap),
      std::end(GPUStencilOperationMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUStencilOperationMap)) return "";

    return it->first;
  };
  
  uint32_t GPUTextureAspect(std::string name) {
    return GPUTextureAspectMap[name];
  };
  std::string GPUTextureAspect(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUTextureAspectMap),
      std::end(GPUTextureAspectMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUTextureAspectMap)) return "";

    return it->first;
  };
  
  uint32_t GPUTextureComponentType(std::string name) {
    return GPUTextureComponentTypeMap[name];
  };
  std::string GPUTextureComponentType(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUTextureComponentTypeMap),
      std::end(GPUTextureComponentTypeMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUTextureComponentTypeMap)) return "";

    return it->first;
  };
  
  uint32_t GPUTextureDimension(std::string name) {
    return GPUTextureDimensionMap[name];
  };
  std::string GPUTextureDimension(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUTextureDimensionMap),
      std::end(GPUTextureDimensionMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUTextureDimensionMap)) return "";

    return it->first;
  };
  
  uint32_t GPUTextureFormat(std::string name) {
    return GPUTextureFormatMap[name];
  };
  std::string GPUTextureFormat(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUTextureFormatMap),
      std::end(GPUTextureFormatMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUTextureFormatMap)) return "";

    return it->first;
  };
  
  uint32_t GPUTextureViewDimension(std::string name) {
    return GPUTextureViewDimensionMap[name];
  };
  std::string GPUTextureViewDimension(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUTextureViewDimensionMap),
      std::end(GPUTextureViewDimensionMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUTextureViewDimensionMap)) return "";

    return it->first;
  };
  
  uint32_t GPUVertexFormat(std::string name) {
    return GPUVertexFormatMap[name];
  };
  std::string GPUVertexFormat(uint32_t value) {
    auto it = std::find_if(
      std::begin(GPUVertexFormatMap),
      std::end(GPUVertexFormatMap),
      [value](auto&& p) {
        return p.second == value;
      }
    );

    if (it == std::end(GPUVertexFormatMap)) return "";

    return it->first;
  };
  

  
  DawnBindGroupBinding GPUBindGroupBinding(GPUDevice* device, Napi::Value& value) {

    DawnBindGroupBinding descriptor;
  descriptor.buffer = nullptr;
  descriptor.offset = 0;
  descriptor.sampler = nullptr;
  descriptor.textureView = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    descriptor.binding = obj.Get("binding").As<Napi::Number>().Uint32Value();
    if (obj.Has("buffer")) {
      if (!(obj.Get("buffer").As<Napi::Object>().InstanceOf(GPUBuffer::constructor.Value()))) {
        Napi::String type = Napi::String::New(value.Env(), "Type");
        Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUBuffer' for 'GPUBindGroupBinding'.'buffer'");
        device->throwCallbackError(type, message);
        return {};
      }
      descriptor.buffer = Napi::ObjectWrap<GPUBuffer>::Unwrap(obj.Get("buffer").As<Napi::Object>())->instance;
    }
    if (obj.Has("offset")) {
      {
        bool lossless;
        descriptor.offset = obj.Get("offset").As<Napi::BigInt>().Uint64Value(&lossless);
      }
    }
    {
      bool lossless;
      descriptor.size = obj.Get("size").As<Napi::BigInt>().Uint64Value(&lossless);
    }
    if (obj.Has("sampler")) {
      if (!(obj.Get("sampler").As<Napi::Object>().InstanceOf(GPUSampler::constructor.Value()))) {
        Napi::String type = Napi::String::New(value.Env(), "Type");
        Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUSampler' for 'GPUBindGroupBinding'.'sampler'");
        device->throwCallbackError(type, message);
        return {};
      }
      descriptor.sampler = Napi::ObjectWrap<GPUSampler>::Unwrap(obj.Get("sampler").As<Napi::Object>())->instance;
    }
    if (obj.Has("textureView")) {
      if (!(obj.Get("textureView").As<Napi::Object>().InstanceOf(GPUTextureView::constructor.Value()))) {
        Napi::String type = Napi::String::New(value.Env(), "Type");
        Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUTextureView' for 'GPUBindGroupBinding'.'textureView'");
        device->throwCallbackError(type, message);
        return {};
      }
      descriptor.textureView = Napi::ObjectWrap<GPUTextureView>::Unwrap(obj.Get("textureView").As<Napi::Object>())->instance;
    }

    return descriptor;
  };
  
  DawnBindGroupDescriptor GPUBindGroupDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnBindGroupDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.layout = nullptr;
  descriptor.bindings = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (!(obj.Get("layout").As<Napi::Object>().InstanceOf(GPUBindGroupLayout::constructor.Value()))) {
      Napi::String type = Napi::String::New(value.Env(), "Type");
      Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUBindGroupLayout' for 'GPUBindGroupDescriptor'.'layout'");
      device->throwCallbackError(type, message);
      return {};
    }
    descriptor.layout = Napi::ObjectWrap<GPUBindGroupLayout>::Unwrap(obj.Get("layout").As<Napi::Object>())->instance;
    {
      Napi::Array array = obj.Get("bindings").As<Napi::Array>();
      uint32_t length = array.Length();
      auto data = new std::vector<DawnBindGroupBinding>;
      for (unsigned int ii = 0; ii < length; ++ii) {
        Napi::Object item = array.Get(ii).As<Napi::Object>();
        DawnBindGroupBinding $bindings = GPUBindGroupBinding(device, item.As<Napi::Value>());
        data->push_back($bindings);
      };
      descriptor.bindingCount = length;
      descriptor.bindings = data->data();
    }

    return descriptor;
  };
  
  DawnBindGroupLayoutBinding GPUBindGroupLayoutBinding(GPUDevice* device, Napi::Value& value) {

    DawnBindGroupLayoutBinding descriptor;
  descriptor.dynamic = false;
  descriptor.multisampled = false;
  descriptor.textureDimension = static_cast<DawnTextureViewDimension>(2);
  descriptor.textureComponentType = static_cast<DawnTextureComponentType>(0);

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    descriptor.binding = obj.Get("binding").As<Napi::Number>().Uint32Value();
    descriptor.visibility = static_cast<DawnShaderStage>(obj.Get("visibility").As<Napi::Number>().Uint32Value());
    descriptor.type = static_cast<DawnBindingType>(GPUBindingType(obj.Get("type").As<Napi::String>().Utf8Value()));
    if (obj.Has("dynamic")) {
      descriptor.dynamic = obj.Get("dynamic").As<Napi::Boolean>().Value();
    }
    if (obj.Has("multisampled")) {
      descriptor.multisampled = obj.Get("multisampled").As<Napi::Boolean>().Value();
    }
    if (obj.Has("textureDimension")) {
      descriptor.textureDimension = static_cast<DawnTextureViewDimension>(GPUTextureViewDimension(obj.Get("textureDimension").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("textureComponentType")) {
      descriptor.textureComponentType = static_cast<DawnTextureComponentType>(GPUTextureComponentType(obj.Get("textureComponentType").As<Napi::String>().Utf8Value()));
    }

    return descriptor;
  };
  
  DawnBindGroupLayoutDescriptor GPUBindGroupLayoutDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnBindGroupLayoutDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.bindings = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    {
      Napi::Array array = obj.Get("bindings").As<Napi::Array>();
      uint32_t length = array.Length();
      auto data = new std::vector<DawnBindGroupLayoutBinding>;
      for (unsigned int ii = 0; ii < length; ++ii) {
        Napi::Object item = array.Get(ii).As<Napi::Object>();
        DawnBindGroupLayoutBinding $bindings = GPUBindGroupLayoutBinding(device, item.As<Napi::Value>());
        data->push_back($bindings);
      };
      descriptor.bindingCount = length;
      descriptor.bindings = data->data();
    }

    return descriptor;
  };
  
  DawnBlendDescriptor GPUBlendDescriptor(GPUDevice* device, Napi::Value& value) {

    DawnBlendDescriptor descriptor;
  descriptor.operation = static_cast<DawnBlendOperation>(0);
  descriptor.srcFactor = static_cast<DawnBlendFactor>(1);
  descriptor.dstFactor = static_cast<DawnBlendFactor>(0);

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (obj.Has("operation")) {
      descriptor.operation = static_cast<DawnBlendOperation>(GPUBlendOperation(obj.Get("operation").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("srcFactor")) {
      descriptor.srcFactor = static_cast<DawnBlendFactor>(GPUBlendFactor(obj.Get("srcFactor").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("dstFactor")) {
      descriptor.dstFactor = static_cast<DawnBlendFactor>(GPUBlendFactor(obj.Get("dstFactor").As<Napi::String>().Utf8Value()));
    }

    return descriptor;
  };
  
  DawnColorStateDescriptor GPUColorStateDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnColorStateDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.writeMask = static_cast<DawnColorWriteMask>(15);

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    descriptor.format = static_cast<DawnTextureFormat>(GPUTextureFormat(obj.Get("format").As<Napi::String>().Utf8Value()));
      descriptor.alphaBlend.operation = static_cast<DawnBlendOperation>(0);
      descriptor.alphaBlend.srcFactor = static_cast<DawnBlendFactor>(1);
      descriptor.alphaBlend.dstFactor = static_cast<DawnBlendFactor>(0);
      Napi::Object $alphaBlend = obj.Get("alphaBlend").As<Napi::Object>();
      if ($alphaBlend.Has("operation")) {
        descriptor.alphaBlend.operation = static_cast<DawnBlendOperation>(GPUBlendOperation($alphaBlend.Get("operation").As<Napi::String>().Utf8Value()));
      }
      if ($alphaBlend.Has("srcFactor")) {
        descriptor.alphaBlend.srcFactor = static_cast<DawnBlendFactor>(GPUBlendFactor($alphaBlend.Get("srcFactor").As<Napi::String>().Utf8Value()));
      }
      if ($alphaBlend.Has("dstFactor")) {
        descriptor.alphaBlend.dstFactor = static_cast<DawnBlendFactor>(GPUBlendFactor($alphaBlend.Get("dstFactor").As<Napi::String>().Utf8Value()));
      }
      descriptor.colorBlend.operation = static_cast<DawnBlendOperation>(0);
      descriptor.colorBlend.srcFactor = static_cast<DawnBlendFactor>(1);
      descriptor.colorBlend.dstFactor = static_cast<DawnBlendFactor>(0);
      Napi::Object $colorBlend = obj.Get("colorBlend").As<Napi::Object>();
      if ($colorBlend.Has("operation")) {
        descriptor.colorBlend.operation = static_cast<DawnBlendOperation>(GPUBlendOperation($colorBlend.Get("operation").As<Napi::String>().Utf8Value()));
      }
      if ($colorBlend.Has("srcFactor")) {
        descriptor.colorBlend.srcFactor = static_cast<DawnBlendFactor>(GPUBlendFactor($colorBlend.Get("srcFactor").As<Napi::String>().Utf8Value()));
      }
      if ($colorBlend.Has("dstFactor")) {
        descriptor.colorBlend.dstFactor = static_cast<DawnBlendFactor>(GPUBlendFactor($colorBlend.Get("dstFactor").As<Napi::String>().Utf8Value()));
      }
    if (obj.Has("writeMask")) {
      descriptor.writeMask = static_cast<DawnColorWriteMask>(obj.Get("writeMask").As<Napi::Number>().Uint32Value());
    }

    return descriptor;
  };
  
  DawnBufferCopyView GPUBufferCopyView(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnBufferCopyView descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.buffer = nullptr;
  descriptor.offset = 0;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (!(obj.Get("buffer").As<Napi::Object>().InstanceOf(GPUBuffer::constructor.Value()))) {
      Napi::String type = Napi::String::New(value.Env(), "Type");
      Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUBuffer' for 'GPUBufferCopyView'.'buffer'");
      device->throwCallbackError(type, message);
      return {};
    }
    descriptor.buffer = Napi::ObjectWrap<GPUBuffer>::Unwrap(obj.Get("buffer").As<Napi::Object>())->instance;
    if (obj.Has("offset")) {
      {
        bool lossless;
        descriptor.offset = obj.Get("offset").As<Napi::BigInt>().Uint64Value(&lossless);
      }
    }
    descriptor.rowPitch = obj.Get("rowPitch").As<Napi::Number>().Uint32Value();
    descriptor.imageHeight = obj.Get("imageHeight").As<Napi::Number>().Uint32Value();

    return descriptor;
  };
  
  DawnBufferDescriptor GPUBufferDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnBufferDescriptor descriptor;
  descriptor.nextInChain = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    descriptor.usage = static_cast<DawnBufferUsage>(obj.Get("usage").As<Napi::Number>().Uint32Value());
    {
      bool lossless;
      descriptor.size = obj.Get("size").As<Napi::BigInt>().Uint64Value(&lossless);
    }

    return descriptor;
  };
  
  DawnCreateBufferMappedResult GPUCreateBufferMappedResult(GPUDevice* device, Napi::Value& value) {

    DawnCreateBufferMappedResult descriptor;
  descriptor.buffer = nullptr;
  descriptor.data = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (!(obj.Get("buffer").As<Napi::Object>().InstanceOf(GPUBuffer::constructor.Value()))) {
      Napi::String type = Napi::String::New(value.Env(), "Type");
      Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUBuffer' for 'GPUCreateBufferMappedResult'.'buffer'");
      device->throwCallbackError(type, message);
      return {};
    }
    descriptor.buffer = Napi::ObjectWrap<GPUBuffer>::Unwrap(obj.Get("buffer").As<Napi::Object>())->instance;
    {
    }

    return descriptor;
  };
  
  DawnColor GPUColor(GPUDevice* device, Napi::Value& value) {

    DawnColor descriptor;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    descriptor.r = obj.Get("r").As<Napi::Number>().FloatValue();
    descriptor.g = obj.Get("g").As<Napi::Number>().FloatValue();
    descriptor.b = obj.Get("b").As<Napi::Number>().FloatValue();
    descriptor.a = obj.Get("a").As<Napi::Number>().FloatValue();

    return descriptor;
  };
  
  DawnCommandBufferDescriptor GPUCommandBufferDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnCommandBufferDescriptor descriptor;
  descriptor.nextInChain = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();

    return descriptor;
  };
  
  DawnCommandEncoderDescriptor GPUCommandEncoderDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnCommandEncoderDescriptor descriptor;
  descriptor.nextInChain = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();

    return descriptor;
  };
  
  DawnComputePassDescriptor GPUComputePassDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnComputePassDescriptor descriptor;
  descriptor.nextInChain = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();

    return descriptor;
  };
  
  DawnComputePipelineDescriptor GPUComputePipelineDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnComputePipelineDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.layout = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (!(obj.Get("layout").As<Napi::Object>().InstanceOf(GPUPipelineLayout::constructor.Value()))) {
      Napi::String type = Napi::String::New(value.Env(), "Type");
      Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUPipelineLayout' for 'GPUComputePipelineDescriptor'.'layout'");
      device->throwCallbackError(type, message);
      return {};
    }
    descriptor.layout = Napi::ObjectWrap<GPUPipelineLayout>::Unwrap(obj.Get("layout").As<Napi::Object>())->instance;
      descriptor.computeStage.nextInChain = nullptr;
      descriptor.computeStage.module = nullptr;
      descriptor.computeStage.entryPoint = nullptr;
      Napi::Object $computeStage = obj.Get("computeStage").As<Napi::Object>();
      if (!($computeStage.Get("module").As<Napi::Object>().InstanceOf(GPUShaderModule::constructor.Value()))) {
        Napi::String type = Napi::String::New(value.Env(), "Type");
        Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUShaderModule' for 'GPUPipelineStageDescriptor'.'module'");
        device->throwCallbackError(type, message);
        return {};
      }
      descriptor.computeStage.module = Napi::ObjectWrap<GPUShaderModule>::Unwrap($computeStage.Get("module").As<Napi::Object>())->instance;
      {
        descriptor.computeStage.entryPoint = getNAPIStringCopy($computeStage.Get("entryPoint"));
      }

    return descriptor;
  };
  
  DawnDepthStencilStateDescriptor GPUDepthStencilStateDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnDepthStencilStateDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.depthWriteEnabled = false;
  descriptor.depthCompare = static_cast<DawnCompareFunction>(7);
  descriptor.stencilReadMask = 0xFFFFFFFF;
  descriptor.stencilWriteMask = 0xFFFFFFFF;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    descriptor.format = static_cast<DawnTextureFormat>(GPUTextureFormat(obj.Get("format").As<Napi::String>().Utf8Value()));
    if (obj.Has("depthWriteEnabled")) {
      descriptor.depthWriteEnabled = obj.Get("depthWriteEnabled").As<Napi::Boolean>().Value();
    }
    if (obj.Has("depthCompare")) {
      descriptor.depthCompare = static_cast<DawnCompareFunction>(GPUCompareFunction(obj.Get("depthCompare").As<Napi::String>().Utf8Value()));
    }
      descriptor.stencilFront.compare = static_cast<DawnCompareFunction>(7);
      descriptor.stencilFront.failOp = static_cast<DawnStencilOperation>(0);
      descriptor.stencilFront.depthFailOp = static_cast<DawnStencilOperation>(0);
      descriptor.stencilFront.passOp = static_cast<DawnStencilOperation>(0);
      Napi::Object $stencilFront = obj.Get("stencilFront").As<Napi::Object>();
      if ($stencilFront.Has("compare")) {
        descriptor.stencilFront.compare = static_cast<DawnCompareFunction>(GPUCompareFunction($stencilFront.Get("compare").As<Napi::String>().Utf8Value()));
      }
      if ($stencilFront.Has("failOp")) {
        descriptor.stencilFront.failOp = static_cast<DawnStencilOperation>(GPUStencilOperation($stencilFront.Get("failOp").As<Napi::String>().Utf8Value()));
      }
      if ($stencilFront.Has("depthFailOp")) {
        descriptor.stencilFront.depthFailOp = static_cast<DawnStencilOperation>(GPUStencilOperation($stencilFront.Get("depthFailOp").As<Napi::String>().Utf8Value()));
      }
      if ($stencilFront.Has("passOp")) {
        descriptor.stencilFront.passOp = static_cast<DawnStencilOperation>(GPUStencilOperation($stencilFront.Get("passOp").As<Napi::String>().Utf8Value()));
      }
      descriptor.stencilBack.compare = static_cast<DawnCompareFunction>(7);
      descriptor.stencilBack.failOp = static_cast<DawnStencilOperation>(0);
      descriptor.stencilBack.depthFailOp = static_cast<DawnStencilOperation>(0);
      descriptor.stencilBack.passOp = static_cast<DawnStencilOperation>(0);
      Napi::Object $stencilBack = obj.Get("stencilBack").As<Napi::Object>();
      if ($stencilBack.Has("compare")) {
        descriptor.stencilBack.compare = static_cast<DawnCompareFunction>(GPUCompareFunction($stencilBack.Get("compare").As<Napi::String>().Utf8Value()));
      }
      if ($stencilBack.Has("failOp")) {
        descriptor.stencilBack.failOp = static_cast<DawnStencilOperation>(GPUStencilOperation($stencilBack.Get("failOp").As<Napi::String>().Utf8Value()));
      }
      if ($stencilBack.Has("depthFailOp")) {
        descriptor.stencilBack.depthFailOp = static_cast<DawnStencilOperation>(GPUStencilOperation($stencilBack.Get("depthFailOp").As<Napi::String>().Utf8Value()));
      }
      if ($stencilBack.Has("passOp")) {
        descriptor.stencilBack.passOp = static_cast<DawnStencilOperation>(GPUStencilOperation($stencilBack.Get("passOp").As<Napi::String>().Utf8Value()));
      }
    if (obj.Has("stencilReadMask")) {
      descriptor.stencilReadMask = obj.Get("stencilReadMask").As<Napi::Number>().Uint32Value();
    }
    if (obj.Has("stencilWriteMask")) {
      descriptor.stencilWriteMask = obj.Get("stencilWriteMask").As<Napi::Number>().Uint32Value();
    }

    return descriptor;
  };
  
  DawnExtent3D GPUExtent3D(GPUDevice* device, Napi::Value& value) {

    DawnExtent3D descriptor;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    descriptor.width = obj.Get("width").As<Napi::Number>().Uint32Value();
    descriptor.height = obj.Get("height").As<Napi::Number>().Uint32Value();
    descriptor.depth = obj.Get("depth").As<Napi::Number>().Uint32Value();

    return descriptor;
  };
  
  DawnFenceDescriptor GPUFenceDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnFenceDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.initialValue = 0;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (obj.Has("initialValue")) {
      {
        bool lossless;
        descriptor.initialValue = obj.Get("initialValue").As<Napi::BigInt>().Uint64Value(&lossless);
      }
    }

    return descriptor;
  };
  
  DawnVertexAttributeDescriptor GPUVertexAttributeDescriptor(GPUDevice* device, Napi::Value& value) {

    DawnVertexAttributeDescriptor descriptor;
  descriptor.offset = 0;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    descriptor.shaderLocation = obj.Get("shaderLocation").As<Napi::Number>().Uint32Value();
    if (obj.Has("offset")) {
      {
        bool lossless;
        descriptor.offset = obj.Get("offset").As<Napi::BigInt>().Uint64Value(&lossless);
      }
    }
    descriptor.format = static_cast<DawnVertexFormat>(GPUVertexFormat(obj.Get("format").As<Napi::String>().Utf8Value()));

    return descriptor;
  };
  
  DawnVertexBufferDescriptor GPUVertexBufferDescriptor(GPUDevice* device, Napi::Value& value) {

    DawnVertexBufferDescriptor descriptor;
  descriptor.stepMode = static_cast<DawnInputStepMode>(0);
  descriptor.attributes = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    {
      bool lossless;
      descriptor.stride = obj.Get("stride").As<Napi::BigInt>().Uint64Value(&lossless);
    }
    if (obj.Has("stepMode")) {
      descriptor.stepMode = static_cast<DawnInputStepMode>(GPUInputStepMode(obj.Get("stepMode").As<Napi::String>().Utf8Value()));
    }
    {
      Napi::Array array = obj.Get("attributes").As<Napi::Array>();
      uint32_t length = array.Length();
      auto data = new std::vector<DawnVertexAttributeDescriptor>;
      for (unsigned int ii = 0; ii < length; ++ii) {
        Napi::Object item = array.Get(ii).As<Napi::Object>();
        DawnVertexAttributeDescriptor $attributes = GPUVertexAttributeDescriptor(device, item.As<Napi::Value>());
        data->push_back($attributes);
      };
      descriptor.attributeCount = length;
      descriptor.attributes = data->data();
    }

    return descriptor;
  };

  DawnVertexInputDescriptor GPUVertexInputDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnVertexInputDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.indexFormat = static_cast<DawnIndexFormat>(1);
  descriptor.bufferCount = 0;
  descriptor.buffers = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (obj.Has("indexFormat")) {
      descriptor.indexFormat = static_cast<DawnIndexFormat>(GPUIndexFormat(obj.Get("indexFormat").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("buffers")) {
      Napi::Array array = obj.Get("buffers").As<Napi::Array>();
      uint32_t length = array.Length();
      auto data = new std::vector<DawnVertexBufferDescriptor>;
      for (unsigned int ii = 0; ii < length; ++ii) {
        Napi::Object item = array.Get(ii).As<Napi::Object>();
        DawnVertexBufferDescriptor $buffers = GPUVertexBufferDescriptor(device, item.As<Napi::Value>());
        data->push_back($buffers);
      };
      descriptor.bufferCount = length;
      descriptor.buffers = data->data();
    }

    return descriptor;
  };
  
  DawnOrigin3D GPUOrigin3D(GPUDevice* device, Napi::Value& value) {

    DawnOrigin3D descriptor;
  descriptor.x = 0;
  descriptor.y = 0;
  descriptor.z = 0;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (obj.Has("x")) {
      descriptor.x = obj.Get("x").As<Napi::Number>().Uint32Value();
    }
    if (obj.Has("y")) {
      descriptor.y = obj.Get("y").As<Napi::Number>().Uint32Value();
    }
    if (obj.Has("z")) {
      descriptor.z = obj.Get("z").As<Napi::Number>().Uint32Value();
    }

    return descriptor;
  };
  
  DawnPipelineLayoutDescriptor GPUPipelineLayoutDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnPipelineLayoutDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.bindGroupLayouts = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    {
      Napi::Array array = obj.Get("bindGroupLayouts").As<Napi::Array>();
      uint32_t length = array.Length();
      std::vector<DawnBindGroupLayout>* data = new std::vector<DawnBindGroupLayout>;
      for (unsigned int ii = 0; ii < length; ++ii) {
        Napi::Object item = array.Get(ii).As<Napi::Object>();
        DawnBindGroupLayout value = Napi::ObjectWrap<GPUBindGroupLayout>::Unwrap(item)->instance;
        data->push_back(value);
      };
      descriptor.bindGroupLayoutCount = length;
      descriptor.bindGroupLayouts = data->data();
    }

    return descriptor;
  };
  
  DawnPipelineStageDescriptor GPUPipelineStageDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnPipelineStageDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.module = nullptr;
  descriptor.entryPoint = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (!(obj.Get("module").As<Napi::Object>().InstanceOf(GPUShaderModule::constructor.Value()))) {
      Napi::String type = Napi::String::New(value.Env(), "Type");
      Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUShaderModule' for 'GPUPipelineStageDescriptor'.'module'");
      device->throwCallbackError(type, message);
      return {};
    }
    descriptor.module = Napi::ObjectWrap<GPUShaderModule>::Unwrap(obj.Get("module").As<Napi::Object>())->instance;
    {
      descriptor.entryPoint = getNAPIStringCopy(obj.Get("entryPoint"));
    }

    return descriptor;
  };
  
  DawnRasterizationStateDescriptor GPURasterizationStateDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnRasterizationStateDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.frontFace = static_cast<DawnFrontFace>(0);
  descriptor.cullMode = static_cast<DawnCullMode>(0);
  descriptor.depthBias = 0;
  descriptor.depthBiasSlopeScale = 0.0f;
  descriptor.depthBiasClamp = 0.0f;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (obj.Has("frontFace")) {
      descriptor.frontFace = static_cast<DawnFrontFace>(GPUFrontFace(obj.Get("frontFace").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("cullMode")) {
      descriptor.cullMode = static_cast<DawnCullMode>(GPUCullMode(obj.Get("cullMode").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("depthBias")) {
      descriptor.depthBias = obj.Get("depthBias").As<Napi::Number>().Int32Value();
    }
    if (obj.Has("depthBiasSlopeScale")) {
      descriptor.depthBiasSlopeScale = obj.Get("depthBiasSlopeScale").As<Napi::Number>().FloatValue();
    }
    if (obj.Has("depthBiasClamp")) {
      descriptor.depthBiasClamp = obj.Get("depthBiasClamp").As<Napi::Number>().FloatValue();
    }

    return descriptor;
  };
  
  DawnRenderBundleDescriptor GPURenderBundleDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnRenderBundleDescriptor descriptor;
  descriptor.nextInChain = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();

    return descriptor;
  };
  
  DawnRenderBundleEncoderDescriptor GPURenderBundleEncoderDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnRenderBundleEncoderDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.colorFormats = nullptr;
  descriptor.sampleCount = 1;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    {
      Napi::Array array = obj.Get("colorFormats").As<Napi::Array>();
      uint32_t length = array.Length();
      std::vector<DawnTextureFormat>* data = new std::vector<DawnTextureFormat>;
      for (unsigned int ii = 0; ii < length; ++ii) {
        Napi::Object item = array.Get(ii).As<Napi::Object>();
        DawnTextureFormat value = static_cast<DawnTextureFormat>(
          GPUTextureFormat(item.As<Napi::String>().Utf8Value())
        );
        data->push_back(value);
      };
      descriptor.colorFormats = data->data();
    }
    if (obj.Has("depthStencilFormat")) {
      descriptor.depthStencilFormat = static_cast<DawnTextureFormat>(GPUTextureFormat(obj.Get("depthStencilFormat").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("sampleCount")) {
      descriptor.sampleCount = obj.Get("sampleCount").As<Napi::Number>().Uint32Value();
    }

    return descriptor;
  };
  
  DawnRenderPassColorAttachmentDescriptor GPURenderPassColorAttachmentDescriptor(GPUDevice* device, Napi::Value& value) {

    DawnRenderPassColorAttachmentDescriptor descriptor;
  descriptor.attachment = nullptr;
  descriptor.resolveTarget = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (!(obj.Get("attachment").As<Napi::Object>().InstanceOf(GPUTextureView::constructor.Value()))) {
      Napi::String type = Napi::String::New(value.Env(), "Type");
      Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUTextureView' for 'GPURenderPassColorAttachmentDescriptor'.'attachment'");
      device->throwCallbackError(type, message);
      return {};
    }
    descriptor.attachment = Napi::ObjectWrap<GPUTextureView>::Unwrap(obj.Get("attachment").As<Napi::Object>())->instance;
    if (obj.Has("resolveTarget")) {
      if (!(obj.Get("resolveTarget").As<Napi::Object>().InstanceOf(GPUTextureView::constructor.Value()))) {
        Napi::String type = Napi::String::New(value.Env(), "Type");
        Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUTextureView' for 'GPURenderPassColorAttachmentDescriptor'.'resolveTarget'");
        device->throwCallbackError(type, message);
        return {};
      }
      descriptor.resolveTarget = Napi::ObjectWrap<GPUTextureView>::Unwrap(obj.Get("resolveTarget").As<Napi::Object>())->instance;
    }
    descriptor.loadOp = static_cast<DawnLoadOp>(GPULoadOp(obj.Get("loadOp").As<Napi::String>().Utf8Value()));
    descriptor.storeOp = static_cast<DawnStoreOp>(GPUStoreOp(obj.Get("storeOp").As<Napi::String>().Utf8Value()));
      Napi::Object $clearColor = obj.Get("clearColor").As<Napi::Object>();
      descriptor.clearColor.r = $clearColor.Get("r").As<Napi::Number>().FloatValue();
      descriptor.clearColor.g = $clearColor.Get("g").As<Napi::Number>().FloatValue();
      descriptor.clearColor.b = $clearColor.Get("b").As<Napi::Number>().FloatValue();
      descriptor.clearColor.a = $clearColor.Get("a").As<Napi::Number>().FloatValue();

    return descriptor;
  };
  
  DawnRenderPassDepthStencilAttachmentDescriptor GPURenderPassDepthStencilAttachmentDescriptor(GPUDevice* device, Napi::Value& value) {

    DawnRenderPassDepthStencilAttachmentDescriptor descriptor;
  descriptor.attachment = nullptr;
  descriptor.clearStencil = 0;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (!(obj.Get("attachment").As<Napi::Object>().InstanceOf(GPUTextureView::constructor.Value()))) {
      Napi::String type = Napi::String::New(value.Env(), "Type");
      Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUTextureView' for 'GPURenderPassDepthStencilAttachmentDescriptor'.'attachment'");
      device->throwCallbackError(type, message);
      return {};
    }
    descriptor.attachment = Napi::ObjectWrap<GPUTextureView>::Unwrap(obj.Get("attachment").As<Napi::Object>())->instance;
    descriptor.depthLoadOp = static_cast<DawnLoadOp>(GPULoadOp(obj.Get("depthLoadOp").As<Napi::String>().Utf8Value()));
    descriptor.depthStoreOp = static_cast<DawnStoreOp>(GPUStoreOp(obj.Get("depthStoreOp").As<Napi::String>().Utf8Value()));
    descriptor.clearDepth = obj.Get("clearDepth").As<Napi::Number>().FloatValue();
    descriptor.stencilLoadOp = static_cast<DawnLoadOp>(GPULoadOp(obj.Get("stencilLoadOp").As<Napi::String>().Utf8Value()));
    descriptor.stencilStoreOp = static_cast<DawnStoreOp>(GPUStoreOp(obj.Get("stencilStoreOp").As<Napi::String>().Utf8Value()));
    if (obj.Has("clearStencil")) {
      descriptor.clearStencil = obj.Get("clearStencil").As<Napi::Number>().Uint32Value();
    }

    return descriptor;
  };
  
  DawnRenderPassDescriptor GPURenderPassDescriptor(GPUDevice* device, Napi::Value& value) {

    DawnRenderPassDescriptor descriptor;
  descriptor.colorAttachments = nullptr;
  descriptor.depthStencilAttachment = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    {
      Napi::Array array = obj.Get("colorAttachments").As<Napi::Array>();
      uint32_t length = array.Length();
      auto data = new std::vector<DawnRenderPassColorAttachmentDescriptor*>;
      for (unsigned int ii = 0; ii < length; ++ii) {
        Napi::Object item = array.Get(ii).As<Napi::Object>();
        DawnRenderPassColorAttachmentDescriptor $colorAttachments = GPURenderPassColorAttachmentDescriptor(device, item.As<Napi::Value>());
        DawnRenderPassColorAttachmentDescriptor* $$colorAttachments = new DawnRenderPassColorAttachmentDescriptor;
        memcpy(
          reinterpret_cast<void*>($$colorAttachments),
          reinterpret_cast<void*>(&$colorAttachments),
          sizeof(DawnRenderPassColorAttachmentDescriptor)
        );
        data->push_back($$colorAttachments);
      };
      descriptor.colorAttachmentCount = length;
      descriptor.colorAttachments = data->data();
    }
    if (obj.Has("depthStencilAttachment")) {
        DawnRenderPassDepthStencilAttachmentDescriptor depthStencilAttachment;
        depthStencilAttachment.attachment = nullptr;
        depthStencilAttachment.clearStencil = 0;
        Napi::Object $depthStencilAttachment = obj.Get("depthStencilAttachment").As<Napi::Object>();
        if (!($depthStencilAttachment.Get("attachment").As<Napi::Object>().InstanceOf(GPUTextureView::constructor.Value()))) {
          Napi::String type = Napi::String::New(value.Env(), "Type");
          Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUTextureView' for 'GPURenderPassDepthStencilAttachmentDescriptor'.'attachment'");
          device->throwCallbackError(type, message);
          return {};
        }
        depthStencilAttachment.attachment = Napi::ObjectWrap<GPUTextureView>::Unwrap($depthStencilAttachment.Get("attachment").As<Napi::Object>())->instance;
        depthStencilAttachment.depthLoadOp = static_cast<DawnLoadOp>(GPULoadOp($depthStencilAttachment.Get("depthLoadOp").As<Napi::String>().Utf8Value()));
        depthStencilAttachment.depthStoreOp = static_cast<DawnStoreOp>(GPUStoreOp($depthStencilAttachment.Get("depthStoreOp").As<Napi::String>().Utf8Value()));
        depthStencilAttachment.clearDepth = $depthStencilAttachment.Get("clearDepth").As<Napi::Number>().FloatValue();
        depthStencilAttachment.stencilLoadOp = static_cast<DawnLoadOp>(GPULoadOp($depthStencilAttachment.Get("stencilLoadOp").As<Napi::String>().Utf8Value()));
        depthStencilAttachment.stencilStoreOp = static_cast<DawnStoreOp>(GPUStoreOp($depthStencilAttachment.Get("stencilStoreOp").As<Napi::String>().Utf8Value()));
        if ($depthStencilAttachment.Has("clearStencil")) {
          depthStencilAttachment.clearStencil = $depthStencilAttachment.Get("clearStencil").As<Napi::Number>().Uint32Value();
        }
      {
        descriptor.depthStencilAttachment = new DawnRenderPassDepthStencilAttachmentDescriptor;
        memcpy(const_cast<DawnRenderPassDepthStencilAttachmentDescriptor*>(descriptor.depthStencilAttachment), &depthStencilAttachment, sizeof(DawnRenderPassDepthStencilAttachmentDescriptor));
      }
    }

    return descriptor;
  };
  
  DawnRenderPipelineDescriptor GPURenderPipelineDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnRenderPipelineDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.layout = nullptr;
  descriptor.fragmentStage = nullptr;
  descriptor.vertexInput = nullptr;
  descriptor.rasterizationState = nullptr;
  descriptor.sampleCount = 1;
  descriptor.depthStencilState = nullptr;
  descriptor.colorStates = nullptr;
  descriptor.sampleMask = 0xFFFFFFFF;
  descriptor.alphaToCoverageEnabled = false;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (!(obj.Get("layout").As<Napi::Object>().InstanceOf(GPUPipelineLayout::constructor.Value()))) {
      Napi::String type = Napi::String::New(value.Env(), "Type");
      Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUPipelineLayout' for 'GPURenderPipelineDescriptor'.'layout'");
      device->throwCallbackError(type, message);
      return {};
    }
    descriptor.layout = Napi::ObjectWrap<GPUPipelineLayout>::Unwrap(obj.Get("layout").As<Napi::Object>())->instance;
      descriptor.vertexStage.nextInChain = nullptr;
      descriptor.vertexStage.module = nullptr;
      descriptor.vertexStage.entryPoint = nullptr;
      Napi::Object $vertexStage = obj.Get("vertexStage").As<Napi::Object>();
      if (!($vertexStage.Get("module").As<Napi::Object>().InstanceOf(GPUShaderModule::constructor.Value()))) {
        Napi::String type = Napi::String::New(value.Env(), "Type");
        Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUShaderModule' for 'GPUPipelineStageDescriptor'.'module'");
        device->throwCallbackError(type, message);
        return {};
      }
      descriptor.vertexStage.module = Napi::ObjectWrap<GPUShaderModule>::Unwrap($vertexStage.Get("module").As<Napi::Object>())->instance;
      {
        descriptor.vertexStage.entryPoint = getNAPIStringCopy($vertexStage.Get("entryPoint"));
      }
    if (obj.Has("fragmentStage")) {
        DawnPipelineStageDescriptor fragmentStage;
        fragmentStage.nextInChain = nullptr;
        fragmentStage.module = nullptr;
        fragmentStage.entryPoint = nullptr;
        Napi::Object $fragmentStage = obj.Get("fragmentStage").As<Napi::Object>();
        if (!($fragmentStage.Get("module").As<Napi::Object>().InstanceOf(GPUShaderModule::constructor.Value()))) {
          Napi::String type = Napi::String::New(value.Env(), "Type");
          Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUShaderModule' for 'GPUPipelineStageDescriptor'.'module'");
          device->throwCallbackError(type, message);
          return {};
        }
        fragmentStage.module = Napi::ObjectWrap<GPUShaderModule>::Unwrap($fragmentStage.Get("module").As<Napi::Object>())->instance;
        {
          fragmentStage.entryPoint = getNAPIStringCopy($fragmentStage.Get("entryPoint"));
        }
      {
        descriptor.fragmentStage = new DawnPipelineStageDescriptor;
        memcpy(const_cast<DawnPipelineStageDescriptor*>(descriptor.fragmentStage), &fragmentStage, sizeof(DawnPipelineStageDescriptor));
      }
    }
    if (obj.Has("vertexInput")) {
        DawnVertexInputDescriptor vertexInput;
        vertexInput.nextInChain = nullptr;
        vertexInput.indexFormat = static_cast<DawnIndexFormat>(1);
        vertexInput.bufferCount = 0;
        vertexInput.buffers = nullptr;
        Napi::Object $vertexInput = obj.Get("vertexInput").As<Napi::Object>();
        if ($vertexInput.Has("indexFormat")) {
          vertexInput.indexFormat = static_cast<DawnIndexFormat>(GPUIndexFormat($vertexInput.Get("indexFormat").As<Napi::String>().Utf8Value()));
        }
        if ($vertexInput.Has("buffers")) {
          Napi::Array array = $vertexInput.Get("buffers").As<Napi::Array>();
          uint32_t length = array.Length();
          auto data = new std::vector<DawnVertexBufferDescriptor>;
          for (unsigned int ii = 0; ii < length; ++ii) {
            Napi::Object item = array.Get(ii).As<Napi::Object>();
            DawnVertexBufferDescriptor $buffers = GPUVertexBufferDescriptor(device, item.As<Napi::Value>());
            data->push_back($buffers);
          };
          vertexInput.bufferCount = length;
          vertexInput.buffers = data->data();
        }
      {
        descriptor.vertexInput = new DawnVertexInputDescriptor;
        memcpy(const_cast<DawnVertexInputDescriptor*>(descriptor.vertexInput), &vertexInput, sizeof(DawnVertexInputDescriptor));
      }
    }
    descriptor.primitiveTopology = static_cast<DawnPrimitiveTopology>(GPUPrimitiveTopology(obj.Get("primitiveTopology").As<Napi::String>().Utf8Value()));
    if (obj.Has("rasterizationState")) {
        DawnRasterizationStateDescriptor rasterizationState;
        rasterizationState.nextInChain = nullptr;
        rasterizationState.frontFace = static_cast<DawnFrontFace>(0);
        rasterizationState.cullMode = static_cast<DawnCullMode>(0);
        rasterizationState.depthBias = 0;
        rasterizationState.depthBiasSlopeScale = 0.0f;
        rasterizationState.depthBiasClamp = 0.0f;
        Napi::Object $rasterizationState = obj.Get("rasterizationState").As<Napi::Object>();
        if ($rasterizationState.Has("frontFace")) {
          rasterizationState.frontFace = static_cast<DawnFrontFace>(GPUFrontFace($rasterizationState.Get("frontFace").As<Napi::String>().Utf8Value()));
        }
        if ($rasterizationState.Has("cullMode")) {
          rasterizationState.cullMode = static_cast<DawnCullMode>(GPUCullMode($rasterizationState.Get("cullMode").As<Napi::String>().Utf8Value()));
        }
        if ($rasterizationState.Has("depthBias")) {
          rasterizationState.depthBias = $rasterizationState.Get("depthBias").As<Napi::Number>().Int32Value();
        }
        if ($rasterizationState.Has("depthBiasSlopeScale")) {
          rasterizationState.depthBiasSlopeScale = $rasterizationState.Get("depthBiasSlopeScale").As<Napi::Number>().FloatValue();
        }
        if ($rasterizationState.Has("depthBiasClamp")) {
          rasterizationState.depthBiasClamp = $rasterizationState.Get("depthBiasClamp").As<Napi::Number>().FloatValue();
        }
      {
        descriptor.rasterizationState = new DawnRasterizationStateDescriptor;
        memcpy(const_cast<DawnRasterizationStateDescriptor*>(descriptor.rasterizationState), &rasterizationState, sizeof(DawnRasterizationStateDescriptor));
      }
    }
    if (obj.Has("sampleCount")) {
      descriptor.sampleCount = obj.Get("sampleCount").As<Napi::Number>().Uint32Value();
    }
    if (obj.Has("depthStencilState")) {
        DawnDepthStencilStateDescriptor depthStencilState;
        depthStencilState.nextInChain = nullptr;
        depthStencilState.depthWriteEnabled = false;
        depthStencilState.depthCompare = static_cast<DawnCompareFunction>(7);
        depthStencilState.stencilReadMask = 0xFFFFFFFF;
        depthStencilState.stencilWriteMask = 0xFFFFFFFF;
        Napi::Object $depthStencilState = obj.Get("depthStencilState").As<Napi::Object>();
        depthStencilState.format = static_cast<DawnTextureFormat>(GPUTextureFormat($depthStencilState.Get("format").As<Napi::String>().Utf8Value()));
        if ($depthStencilState.Has("depthWriteEnabled")) {
          depthStencilState.depthWriteEnabled = $depthStencilState.Get("depthWriteEnabled").As<Napi::Boolean>().Value();
        }
        if ($depthStencilState.Has("depthCompare")) {
          depthStencilState.depthCompare = static_cast<DawnCompareFunction>(GPUCompareFunction($depthStencilState.Get("depthCompare").As<Napi::String>().Utf8Value()));
        }
          depthStencilState.stencilFront.compare = static_cast<DawnCompareFunction>(7);
          depthStencilState.stencilFront.failOp = static_cast<DawnStencilOperation>(0);
          depthStencilState.stencilFront.depthFailOp = static_cast<DawnStencilOperation>(0);
          depthStencilState.stencilFront.passOp = static_cast<DawnStencilOperation>(0);
          Napi::Object $stencilFront = $depthStencilState.Get("stencilFront").As<Napi::Object>();
          if ($stencilFront.Has("compare")) {
            depthStencilState.stencilFront.compare = static_cast<DawnCompareFunction>(GPUCompareFunction($stencilFront.Get("compare").As<Napi::String>().Utf8Value()));
          }
          if ($stencilFront.Has("failOp")) {
            depthStencilState.stencilFront.failOp = static_cast<DawnStencilOperation>(GPUStencilOperation($stencilFront.Get("failOp").As<Napi::String>().Utf8Value()));
          }
          if ($stencilFront.Has("depthFailOp")) {
            depthStencilState.stencilFront.depthFailOp = static_cast<DawnStencilOperation>(GPUStencilOperation($stencilFront.Get("depthFailOp").As<Napi::String>().Utf8Value()));
          }
          if ($stencilFront.Has("passOp")) {
            depthStencilState.stencilFront.passOp = static_cast<DawnStencilOperation>(GPUStencilOperation($stencilFront.Get("passOp").As<Napi::String>().Utf8Value()));
          }
          depthStencilState.stencilBack.compare = static_cast<DawnCompareFunction>(7);
          depthStencilState.stencilBack.failOp = static_cast<DawnStencilOperation>(0);
          depthStencilState.stencilBack.depthFailOp = static_cast<DawnStencilOperation>(0);
          depthStencilState.stencilBack.passOp = static_cast<DawnStencilOperation>(0);
          Napi::Object $stencilBack = $depthStencilState.Get("stencilBack").As<Napi::Object>();
          if ($stencilBack.Has("compare")) {
            depthStencilState.stencilBack.compare = static_cast<DawnCompareFunction>(GPUCompareFunction($stencilBack.Get("compare").As<Napi::String>().Utf8Value()));
          }
          if ($stencilBack.Has("failOp")) {
            depthStencilState.stencilBack.failOp = static_cast<DawnStencilOperation>(GPUStencilOperation($stencilBack.Get("failOp").As<Napi::String>().Utf8Value()));
          }
          if ($stencilBack.Has("depthFailOp")) {
            depthStencilState.stencilBack.depthFailOp = static_cast<DawnStencilOperation>(GPUStencilOperation($stencilBack.Get("depthFailOp").As<Napi::String>().Utf8Value()));
          }
          if ($stencilBack.Has("passOp")) {
            depthStencilState.stencilBack.passOp = static_cast<DawnStencilOperation>(GPUStencilOperation($stencilBack.Get("passOp").As<Napi::String>().Utf8Value()));
          }
        if ($depthStencilState.Has("stencilReadMask")) {
          depthStencilState.stencilReadMask = $depthStencilState.Get("stencilReadMask").As<Napi::Number>().Uint32Value();
        }
        if ($depthStencilState.Has("stencilWriteMask")) {
          depthStencilState.stencilWriteMask = $depthStencilState.Get("stencilWriteMask").As<Napi::Number>().Uint32Value();
        }
      {
        descriptor.depthStencilState = new DawnDepthStencilStateDescriptor;
        memcpy(const_cast<DawnDepthStencilStateDescriptor*>(descriptor.depthStencilState), &depthStencilState, sizeof(DawnDepthStencilStateDescriptor));
      }
    }
    {
      Napi::Array array = obj.Get("colorStates").As<Napi::Array>();
      uint32_t length = array.Length();
      auto data = new std::vector<DawnColorStateDescriptor*>;
      for (unsigned int ii = 0; ii < length; ++ii) {
        Napi::Object item = array.Get(ii).As<Napi::Object>();
        DawnColorStateDescriptor $colorStates = GPUColorStateDescriptor(device, item.As<Napi::Value>());
        DawnColorStateDescriptor* $$colorStates = new DawnColorStateDescriptor;
        memcpy(
          reinterpret_cast<void*>($$colorStates),
          reinterpret_cast<void*>(&$colorStates),
          sizeof(DawnColorStateDescriptor)
        );
        data->push_back($$colorStates);
      };
      descriptor.colorStateCount = length;
      descriptor.colorStates = data->data();
    }
    if (obj.Has("sampleMask")) {
      descriptor.sampleMask = obj.Get("sampleMask").As<Napi::Number>().Uint32Value();
    }
    if (obj.Has("alphaToCoverageEnabled")) {
      descriptor.alphaToCoverageEnabled = obj.Get("alphaToCoverageEnabled").As<Napi::Boolean>().Value();
    }

    return descriptor;
  };
  
  DawnSamplerDescriptor GPUSamplerDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnSamplerDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.addressModeU = static_cast<DawnAddressMode>(2);
  descriptor.addressModeV = static_cast<DawnAddressMode>(2);
  descriptor.addressModeW = static_cast<DawnAddressMode>(2);
  descriptor.magFilter = static_cast<DawnFilterMode>(0);
  descriptor.minFilter = static_cast<DawnFilterMode>(0);
  descriptor.mipmapFilter = static_cast<DawnFilterMode>(0);
  descriptor.lodMinClamp = 0.0f;
  descriptor.lodMaxClamp = 1000.0f;
  descriptor.compare = static_cast<DawnCompareFunction>(0);

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (obj.Has("addressModeU")) {
      descriptor.addressModeU = static_cast<DawnAddressMode>(GPUAddressMode(obj.Get("addressModeU").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("addressModeV")) {
      descriptor.addressModeV = static_cast<DawnAddressMode>(GPUAddressMode(obj.Get("addressModeV").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("addressModeW")) {
      descriptor.addressModeW = static_cast<DawnAddressMode>(GPUAddressMode(obj.Get("addressModeW").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("magFilter")) {
      descriptor.magFilter = static_cast<DawnFilterMode>(GPUFilterMode(obj.Get("magFilter").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("minFilter")) {
      descriptor.minFilter = static_cast<DawnFilterMode>(GPUFilterMode(obj.Get("minFilter").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("mipmapFilter")) {
      descriptor.mipmapFilter = static_cast<DawnFilterMode>(GPUFilterMode(obj.Get("mipmapFilter").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("lodMinClamp")) {
      descriptor.lodMinClamp = obj.Get("lodMinClamp").As<Napi::Number>().FloatValue();
    }
    if (obj.Has("lodMaxClamp")) {
      descriptor.lodMaxClamp = obj.Get("lodMaxClamp").As<Napi::Number>().FloatValue();
    }
    if (obj.Has("compare")) {
      descriptor.compare = static_cast<DawnCompareFunction>(GPUCompareFunction(obj.Get("compare").As<Napi::String>().Utf8Value()));
    }

    return descriptor;
  };
  
  DawnShaderModuleDescriptor GPUShaderModuleDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnShaderModuleDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.code = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    {
    }

    return descriptor;
  };
  
  DawnStencilStateFaceDescriptor GPUStencilStateFaceDescriptor(GPUDevice* device, Napi::Value& value) {

    DawnStencilStateFaceDescriptor descriptor;
  descriptor.compare = static_cast<DawnCompareFunction>(7);
  descriptor.failOp = static_cast<DawnStencilOperation>(0);
  descriptor.depthFailOp = static_cast<DawnStencilOperation>(0);
  descriptor.passOp = static_cast<DawnStencilOperation>(0);

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (obj.Has("compare")) {
      descriptor.compare = static_cast<DawnCompareFunction>(GPUCompareFunction(obj.Get("compare").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("failOp")) {
      descriptor.failOp = static_cast<DawnStencilOperation>(GPUStencilOperation(obj.Get("failOp").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("depthFailOp")) {
      descriptor.depthFailOp = static_cast<DawnStencilOperation>(GPUStencilOperation(obj.Get("depthFailOp").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("passOp")) {
      descriptor.passOp = static_cast<DawnStencilOperation>(GPUStencilOperation(obj.Get("passOp").As<Napi::String>().Utf8Value()));
    }

    return descriptor;
  };
  
  DawnSwapChainDescriptor GPUSwapChainDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnSwapChainDescriptor descriptor;
  descriptor.nextInChain = nullptr;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    {
      bool lossless;
      descriptor.implementation = obj.Get("implementation").As<Napi::BigInt>().Uint64Value(&lossless);
    }

    return descriptor;
  };
  
  DawnTextureCopyView GPUTextureCopyView(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnTextureCopyView descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.texture = nullptr;
  descriptor.mipLevel = 0;
  descriptor.arrayLayer = 0;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (!(obj.Get("texture").As<Napi::Object>().InstanceOf(GPUTexture::constructor.Value()))) {
      Napi::String type = Napi::String::New(value.Env(), "Type");
      Napi::String message = Napi::String::New(value.Env(), "Expected type 'GPUTexture' for 'GPUTextureCopyView'.'texture'");
      device->throwCallbackError(type, message);
      return {};
    }
    descriptor.texture = Napi::ObjectWrap<GPUTexture>::Unwrap(obj.Get("texture").As<Napi::Object>())->instance;
    if (obj.Has("mipLevel")) {
      descriptor.mipLevel = obj.Get("mipLevel").As<Napi::Number>().Uint32Value();
    }
    if (obj.Has("arrayLayer")) {
      descriptor.arrayLayer = obj.Get("arrayLayer").As<Napi::Number>().Uint32Value();
    }
      descriptor.origin.x = 0;
      descriptor.origin.y = 0;
      descriptor.origin.z = 0;
      Napi::Object $origin = obj.Get("origin").As<Napi::Object>();
      if ($origin.Has("x")) {
        descriptor.origin.x = $origin.Get("x").As<Napi::Number>().Uint32Value();
      }
      if ($origin.Has("y")) {
        descriptor.origin.y = $origin.Get("y").As<Napi::Number>().Uint32Value();
      }
      if ($origin.Has("z")) {
        descriptor.origin.z = $origin.Get("z").As<Napi::Number>().Uint32Value();
      }

    return descriptor;
  };
  
  DawnTextureDescriptor GPUTextureDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnTextureDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.dimension = static_cast<DawnTextureDimension>(1);
  descriptor.arrayLayerCount = 1;
  descriptor.mipLevelCount = 1;
  descriptor.sampleCount = 1;

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    descriptor.usage = static_cast<DawnTextureUsage>(obj.Get("usage").As<Napi::Number>().Uint32Value());
    if (obj.Has("dimension")) {
      descriptor.dimension = static_cast<DawnTextureDimension>(GPUTextureDimension(obj.Get("dimension").As<Napi::String>().Utf8Value()));
    }
      Napi::Object $size = obj.Get("size").As<Napi::Object>();
      descriptor.size.width = $size.Get("width").As<Napi::Number>().Uint32Value();
      descriptor.size.height = $size.Get("height").As<Napi::Number>().Uint32Value();
      descriptor.size.depth = $size.Get("depth").As<Napi::Number>().Uint32Value();
    if (obj.Has("arrayLayerCount")) {
      descriptor.arrayLayerCount = obj.Get("arrayLayerCount").As<Napi::Number>().Uint32Value();
    }
    descriptor.format = static_cast<DawnTextureFormat>(GPUTextureFormat(obj.Get("format").As<Napi::String>().Utf8Value()));
    if (obj.Has("mipLevelCount")) {
      descriptor.mipLevelCount = obj.Get("mipLevelCount").As<Napi::Number>().Uint32Value();
    }
    if (obj.Has("sampleCount")) {
      descriptor.sampleCount = obj.Get("sampleCount").As<Napi::Number>().Uint32Value();
    }

    return descriptor;
  };
  
  DawnTextureViewDescriptor GPUTextureViewDescriptor(GPUDevice* device, Napi::Value& value, void* nextInChain) {

    DawnTextureViewDescriptor descriptor;
  descriptor.nextInChain = nullptr;
  descriptor.dimension = static_cast<DawnTextureViewDimension>(2);
  descriptor.baseMipLevel = 0;
  descriptor.mipLevelCount = 0;
  descriptor.baseArrayLayer = 0;
  descriptor.arrayLayerCount = 0;
  descriptor.aspect = static_cast<DawnTextureAspect>(0);

    if (!(value.IsObject())) return descriptor;

    Napi::Object obj = value.As<Napi::Object>();
    if (obj.Has("format")) {
      descriptor.format = static_cast<DawnTextureFormat>(GPUTextureFormat(obj.Get("format").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("dimension")) {
      descriptor.dimension = static_cast<DawnTextureViewDimension>(GPUTextureViewDimension(obj.Get("dimension").As<Napi::String>().Utf8Value()));
    }
    if (obj.Has("baseMipLevel")) {
      descriptor.baseMipLevel = obj.Get("baseMipLevel").As<Napi::Number>().Uint32Value();
    }
    if (obj.Has("mipLevelCount")) {
      descriptor.mipLevelCount = obj.Get("mipLevelCount").As<Napi::Number>().Uint32Value();
    }
    if (obj.Has("baseArrayLayer")) {
      descriptor.baseArrayLayer = obj.Get("baseArrayLayer").As<Napi::Number>().Uint32Value();
    }
    if (obj.Has("arrayLayerCount")) {
      descriptor.arrayLayerCount = obj.Get("arrayLayerCount").As<Napi::Number>().Uint32Value();
    }
    if (obj.Has("aspect")) {
      descriptor.aspect = static_cast<DawnTextureAspect>(GPUTextureAspect(obj.Get("aspect").As<Napi::String>().Utf8Value()));
    }

    return descriptor;
  };
  
}
