/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY nwgpu v0.0.1
 */
#ifndef __DESCRIPTOR_DECODER_H__
#define __DESCRIPTOR_DECODER_H__

#include "Base.h"
#include "Utils.h"

#include "GPUDevice.h"
#include "GPUAdapter.h"
#include "GPUQueue.h"
#include "GPUFence.h"
#include "GPUBuffer.h"
#include "GPUTexture.h"
#include "GPUTextureView.h"
#include "GPUSampler.h"
#include "GPUBindGroupLayout.h"
#include "GPUPipelineLayout.h"
#include "GPUBindGroup.h"
#include "GPUShaderModule.h"
#include "GPURenderPipeline.h"

#include <unordered_map>


static std::unordered_map<std::string, uint32_t> GPUAddressMode = {
  { "repeat", 0 },
  { "mirror repeat", 1 },
  { "clamp to edge", 2 },
};

static std::unordered_map<std::string, uint32_t> GPUBindingType = {
  { "uniform buffer", 0 },
  { "storage buffer", 1 },
  { "readonly storage buffer", 2 },
  { "sampler", 3 },
  { "sampled texture", 4 },
  { "storage texture", 5 },
};

static std::unordered_map<std::string, uint32_t> GPUBlendFactor = {
  { "zero", 0 },
  { "one", 1 },
  { "src color", 2 },
  { "one minus src color", 3 },
  { "src alpha", 4 },
  { "one minus src alpha", 5 },
  { "dst color", 6 },
  { "one minus dst color", 7 },
  { "dst alpha", 8 },
  { "one minus dst alpha", 9 },
  { "src alpha saturated", 10 },
  { "blend color", 11 },
  { "one minus blend color", 12 },
};

static std::unordered_map<std::string, uint32_t> GPUBlendOperation = {
  { "add", 0 },
  { "subtract", 1 },
  { "reverse subtract", 2 },
  { "min", 3 },
  { "max", 4 },
};

static std::unordered_map<std::string, uint32_t> GPUBufferMapAsyncStatus = {
  { "success", 0 },
  { "error", 1 },
  { "unknown", 2 },
  { "device lost", 3 },
};

static std::unordered_map<std::string, uint32_t> GPUCompareFunction = {
  { "never", 0 },
  { "less", 1 },
  { "less equal", 2 },
  { "greater", 3 },
  { "greater equal", 4 },
  { "equal", 5 },
  { "not equal", 6 },
  { "always", 7 },
};

static std::unordered_map<std::string, uint32_t> GPUCullMode = {
  { "none", 0 },
  { "front", 1 },
  { "back", 2 },
};

static std::unordered_map<std::string, uint32_t> GPUErrorFilter = {
  { "none", 0 },
  { "validation", 1 },
  { "out of memory", 2 },
};

static std::unordered_map<std::string, uint32_t> GPUErrorType = {
  { "no error", 0 },
  { "validation", 1 },
  { "out of memory", 2 },
  { "unknown", 3 },
  { "device lost", 4 },
};

static std::unordered_map<std::string, uint32_t> GPUFenceCompletionStatus = {
  { "success", 0 },
  { "error", 1 },
  { "unknown", 2 },
  { "device lost", 3 },
};

static std::unordered_map<std::string, uint32_t> GPUFilterMode = {
  { "nearest", 0 },
  { "linear", 1 },
};

static std::unordered_map<std::string, uint32_t> GPUFrontFace = {
  { "CCW", 0 },
  { "CW", 1 },
};

static std::unordered_map<std::string, uint32_t> GPUIndexFormat = {
  { "uint16", 0 },
  { "uint32", 1 },
};

static std::unordered_map<std::string, uint32_t> GPUInputStepMode = {
  { "vertex", 0 },
  { "instance", 1 },
};

static std::unordered_map<std::string, uint32_t> GPULoadOp = {
  { "clear", 0 },
  { "load", 1 },
};

static std::unordered_map<std::string, uint32_t> GPUStoreOp = {
  { "store", 0 },
};

static std::unordered_map<std::string, uint32_t> GPUPrimitiveTopology = {
  { "point list", 0 },
  { "line list", 1 },
  { "line strip", 2 },
  { "triangle list", 3 },
  { "triangle strip", 4 },
};

static std::unordered_map<std::string, uint32_t> GPUStencilOperation = {
  { "keep", 0 },
  { "zero", 1 },
  { "replace", 2 },
  { "invert", 3 },
  { "increment clamp", 4 },
  { "decrement clamp", 5 },
  { "increment wrap", 6 },
  { "decrement wrap", 7 },
};

static std::unordered_map<std::string, uint32_t> GPUTextureAspect = {
  { "all", 0 },
  { "stencil only", 1 },
  { "depth only", 2 },
};

static std::unordered_map<std::string, uint32_t> GPUTextureComponentType = {
  { "float", 0 },
  { "sint", 1 },
  { "uint", 2 },
};

static std::unordered_map<std::string, uint32_t> GPUTextureDimension = {
  { "1D", 0 },
  { "2D", 1 },
  { "3D", 2 },
};

static std::unordered_map<std::string, uint32_t> GPUTextureFormat = {
  { "undefined", 0 },
  { "R8 unorm", 1 },
  { "R8 snorm", 2 },
  { "R8 uint", 3 },
  { "R8 sint", 4 },
  { "R16 uint", 5 },
  { "R16 sint", 6 },
  { "R16 float", 7 },
  { "RG8 unorm", 8 },
  { "RG8 snorm", 9 },
  { "RG8 uint", 10 },
  { "RG8 sint", 11 },
  { "R32 float", 12 },
  { "R32 uint", 13 },
  { "R32 sint", 14 },
  { "RG16 uint", 15 },
  { "RG16 sint", 16 },
  { "RG16 float", 17 },
  { "RGBA8 unorm", 18 },
  { "RGBA8 unorm srgb", 19 },
  { "RGBA8 snorm", 20 },
  { "RGBA8 uint", 21 },
  { "RGBA8 sint", 22 },
  { "BGRA8 unorm", 23 },
  { "BGRA8 unorm srgb", 24 },
  { "RGB10 A2 unorm", 25 },
  { "RG11 B10 float", 26 },
  { "RG32 float", 27 },
  { "RG32 uint", 28 },
  { "RG32 sint", 29 },
  { "RGBA16 uint", 30 },
  { "RGBA16 sint", 31 },
  { "RGBA16 float", 32 },
  { "RGBA32 float", 33 },
  { "RGBA32 uint", 34 },
  { "RGBA32 sint", 35 },
  { "depth32 float", 36 },
  { "depth24 plus", 37 },
  { "depth24 plus stencil8", 38 },
  { "BC1 RGBA unorm", 39 },
  { "BC1 RGBA unorm srgb", 40 },
  { "BC2 RGBA unorm", 41 },
  { "BC2 RGBA unorm srgb", 42 },
  { "BC3 RGBA unorm", 43 },
  { "BC3 RGBA unorm srgb", 44 },
  { "BC4 R unorm", 45 },
  { "BC4 R snorm", 46 },
  { "BC5 RG unorm", 47 },
  { "BC5 RG snorm", 48 },
  { "BC6H RGB ufloat", 49 },
  { "BC6H RGB sfloat", 50 },
  { "BC7 RGBA unorm", 51 },
  { "BC7 RGBA unorm srgb", 52 },
};

static std::unordered_map<std::string, uint32_t> GPUTextureViewDimension = {
  { "undefined", 0 },
  { "1D", 1 },
  { "2D", 2 },
  { "2D array", 3 },
  { "cube", 4 },
  { "cube array", 5 },
  { "3D", 6 },
};

static std::unordered_map<std::string, uint32_t> GPUVertexFormat = {
  { "uChar2", 0 },
  { "uChar4", 1 },
  { "char2", 2 },
  { "char4", 3 },
  { "uChar2 norm", 4 },
  { "uChar4 norm", 5 },
  { "char2 norm", 6 },
  { "char4 norm", 7 },
  { "uShort2", 8 },
  { "uShort4", 9 },
  { "short2", 10 },
  { "short4", 11 },
  { "uShort2 norm", 12 },
  { "uShort4 norm", 13 },
  { "short2 norm", 14 },
  { "short4 norm", 15 },
  { "half2", 16 },
  { "half4", 17 },
  { "float", 18 },
  { "float2", 19 },
  { "float3", 20 },
  { "float4", 21 },
  { "uInt", 22 },
  { "uInt2", 23 },
  { "uInt3", 24 },
  { "uInt4", 25 },
  { "int", 26 },
  { "int2", 27 },
  { "int3", 28 },
  { "int4", 29 },
};


namespace DescriptorDecoder {
  
  DawnBindGroupBinding GPUBindGroupBinding(Napi::Object& device, Napi::Object& value) {

    DawnBindGroupBinding descriptor;
    descriptor.offset = 0;
    {
      descriptor.binding = value.Get("binding").As<Napi::Number>().Uint32Value();
    }
    {
      if (!(value.Get("buffer").As<Napi::Object>().InstanceOf(GPUBuffer::constructor.Value()))) {
        //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUBuffer' for 'GPUBindGroupBinding'.'buffer'");
        return {};
      }
      descriptor.buffer = Napi::ObjectWrap<GPUBuffer>::Unwrap(value.Get("buffer").As<Napi::Object>())->instance;
    }
    if (value.Has("offset")) {
      bool lossless;
      descriptor.offset = value.Get("offset").As<Napi::BigInt>().Uint64Value(&lossless);
    }
    {
      bool lossless;
      descriptor.size = value.Get("size").As<Napi::BigInt>().Uint64Value(&lossless);
    }
    {
      if (!(value.Get("sampler").As<Napi::Object>().InstanceOf(GPUSampler::constructor.Value()))) {
        //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUSampler' for 'GPUBindGroupBinding'.'sampler'");
        return {};
      }
      descriptor.sampler = Napi::ObjectWrap<GPUSampler>::Unwrap(value.Get("sampler").As<Napi::Object>())->instance;
    }
    {
      if (!(value.Get("textureView").As<Napi::Object>().InstanceOf(GPUTextureView::constructor.Value()))) {
        //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUTextureView' for 'GPUBindGroupBinding'.'textureView'");
        return {};
      }
      descriptor.textureView = Napi::ObjectWrap<GPUTextureView>::Unwrap(value.Get("textureView").As<Napi::Object>())->instance;
    }

    return descriptor;
  };
  
  DawnBindGroupDescriptor GPUBindGroupDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnBindGroupDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    {
      if (!(value.Get("layout").As<Napi::Object>().InstanceOf(GPUBindGroupLayout::constructor.Value()))) {
        //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUBindGroupLayout' for 'GPUBindGroupDescriptor'.'layout'");
        return {};
      }
      descriptor.layout = Napi::ObjectWrap<GPUBindGroupLayout>::Unwrap(value.Get("layout").As<Napi::Object>())->instance;
    }
    {
      descriptor.bindingCount = value.Get("bindingCount").As<Napi::Number>().Uint32Value();
    }
    {
      Napi::Array array = value.Get("bindings").As<Napi::Array>();
      uint32_t length = array.Length();
      std::vector<DawnBindGroupBinding> data;
      for (unsigned int ii = 0; ii < length; ++ii) {
        Napi::Object item = array.Get(ii).As<Napi::Object>();
        DawnBindGroupBinding $bindings;
        {
          $bindings.binding = item.Get("binding").As<Napi::Number>().Uint32Value();
        }
        {
          if (!(item.Get("buffer").As<Napi::Object>().InstanceOf(GPUBuffer::constructor.Value()))) {
            //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUBuffer' for 'GPUBindGroupBinding'.'buffer'");
            return {};
          }
          $bindings.buffer = Napi::ObjectWrap<GPUBuffer>::Unwrap(item.Get("buffer").As<Napi::Object>())->instance;
        }
        if (item.Has("offset")) {
          bool lossless;
          $bindings.offset = item.Get("offset").As<Napi::BigInt>().Uint64Value(&lossless);
        }
        {
          bool lossless;
          $bindings.size = item.Get("size").As<Napi::BigInt>().Uint64Value(&lossless);
        }
        {
          if (!(item.Get("sampler").As<Napi::Object>().InstanceOf(GPUSampler::constructor.Value()))) {
            //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUSampler' for 'GPUBindGroupBinding'.'sampler'");
            return {};
          }
          $bindings.sampler = Napi::ObjectWrap<GPUSampler>::Unwrap(item.Get("sampler").As<Napi::Object>())->instance;
        }
        {
          if (!(item.Get("textureView").As<Napi::Object>().InstanceOf(GPUTextureView::constructor.Value()))) {
            //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUTextureView' for 'GPUBindGroupBinding'.'textureView'");
            return {};
          }
          $bindings.textureView = Napi::ObjectWrap<GPUTextureView>::Unwrap(item.Get("textureView").As<Napi::Object>())->instance;
        }
        data.push_back($bindings);
      };
      descriptor.bindingCount = length;
      descriptor.bindings = data.data();
    }

    return descriptor;
  };
  
  DawnBindGroupLayoutBinding GPUBindGroupLayoutBinding(Napi::Object& device, Napi::Object& value) {

    DawnBindGroupLayoutBinding descriptor;
    descriptor.dynamic = false;
    descriptor.multisampled = false;
    descriptor.textureComponentType = static_cast<DawnTextureComponentType>(0);
    {
      descriptor.binding = value.Get("binding").As<Napi::Number>().Uint32Value();
    }
    {
      descriptor.visibility = static_cast<DawnShaderStage>(value.Get("visibility").As<Napi::Number>().Uint32Value());
    }
    {
      descriptor.type = static_cast<DawnBindingType>(GPUBindingType[value.Get("type").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("dynamic")) {
      descriptor.dynamic = value.Get("dynamic").As<Napi::Boolean>().Value();
    }
    if (value.Has("multisampled")) {
      descriptor.multisampled = value.Get("multisampled").As<Napi::Boolean>().Value();
    }
    if (value.Has("textureDimension")) {
      descriptor.textureDimension = static_cast<DawnTextureViewDimension>(GPUTextureViewDimension[value.Get("textureDimension").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("textureComponentType")) {
      descriptor.textureComponentType = static_cast<DawnTextureComponentType>(GPUTextureComponentType[value.Get("textureComponentType").As<Napi::String>().Utf8Value()]);
    }

    return descriptor;
  };
  
  DawnBindGroupLayoutDescriptor GPUBindGroupLayoutDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnBindGroupLayoutDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    {
      descriptor.bindingCount = value.Get("bindingCount").As<Napi::Number>().Uint32Value();
    }
    {
      Napi::Array array = value.Get("bindings").As<Napi::Array>();
      uint32_t length = array.Length();
      std::vector<DawnBindGroupLayoutBinding> data;
      for (unsigned int ii = 0; ii < length; ++ii) {
        Napi::Object item = array.Get(ii).As<Napi::Object>();
        DawnBindGroupLayoutBinding $bindings;
        {
          $bindings.binding = item.Get("binding").As<Napi::Number>().Uint32Value();
        }
        {
          $bindings.visibility = static_cast<DawnShaderStage>(item.Get("visibility").As<Napi::Number>().Uint32Value());
        }
        {
          $bindings.type = static_cast<DawnBindingType>(GPUBindingType[item.Get("type").As<Napi::String>().Utf8Value()]);
        }
        if (item.Has("dynamic")) {
          $bindings.dynamic = item.Get("dynamic").As<Napi::Boolean>().Value();
        }
        if (item.Has("multisampled")) {
          $bindings.multisampled = item.Get("multisampled").As<Napi::Boolean>().Value();
        }
        if (item.Has("textureDimension")) {
          $bindings.textureDimension = static_cast<DawnTextureViewDimension>(GPUTextureViewDimension[item.Get("textureDimension").As<Napi::String>().Utf8Value()]);
        }
        if (item.Has("textureComponentType")) {
          $bindings.textureComponentType = static_cast<DawnTextureComponentType>(GPUTextureComponentType[item.Get("textureComponentType").As<Napi::String>().Utf8Value()]);
        }
        data.push_back($bindings);
      };
      descriptor.bindingCount = length;
      descriptor.bindings = data.data();
    }

    return descriptor;
  };
  
  DawnBlendDescriptor GPUBlendDescriptor(Napi::Object& device, Napi::Object& value) {

    DawnBlendDescriptor descriptor;
    descriptor.operation = static_cast<DawnBlendOperation>(0);
    descriptor.srcFactor = static_cast<DawnBlendFactor>(1);
    descriptor.dstFactor = static_cast<DawnBlendFactor>(0);
    if (value.Has("operation")) {
      descriptor.operation = static_cast<DawnBlendOperation>(GPUBlendOperation[value.Get("operation").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("srcFactor")) {
      descriptor.srcFactor = static_cast<DawnBlendFactor>(GPUBlendFactor[value.Get("srcFactor").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("dstFactor")) {
      descriptor.dstFactor = static_cast<DawnBlendFactor>(GPUBlendFactor[value.Get("dstFactor").As<Napi::String>().Utf8Value()]);
    }

    return descriptor;
  };
  
  DawnColorStateDescriptor GPUColorStateDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnColorStateDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    descriptor.writeMask = static_cast<DawnColorWriteMask>(15);
    {
      descriptor.format = static_cast<DawnTextureFormat>(GPUTextureFormat[value.Get("format").As<Napi::String>().Utf8Value()]);
    }
    {
      Napi::Object $alphaBlend = value.Get("alphaBlend").As<Napi::Object>();
      if ($alphaBlend.Has("operation")) {
        descriptor.alphaBlend.operation = static_cast<DawnBlendOperation>(GPUBlendOperation[$alphaBlend.Get("operation").As<Napi::String>().Utf8Value()]);
      }
      if ($alphaBlend.Has("srcFactor")) {
        descriptor.alphaBlend.srcFactor = static_cast<DawnBlendFactor>(GPUBlendFactor[$alphaBlend.Get("srcFactor").As<Napi::String>().Utf8Value()]);
      }
      if ($alphaBlend.Has("dstFactor")) {
        descriptor.alphaBlend.dstFactor = static_cast<DawnBlendFactor>(GPUBlendFactor[$alphaBlend.Get("dstFactor").As<Napi::String>().Utf8Value()]);
      }
    }
    {
      Napi::Object $colorBlend = value.Get("colorBlend").As<Napi::Object>();
      if ($colorBlend.Has("operation")) {
        descriptor.colorBlend.operation = static_cast<DawnBlendOperation>(GPUBlendOperation[$colorBlend.Get("operation").As<Napi::String>().Utf8Value()]);
      }
      if ($colorBlend.Has("srcFactor")) {
        descriptor.colorBlend.srcFactor = static_cast<DawnBlendFactor>(GPUBlendFactor[$colorBlend.Get("srcFactor").As<Napi::String>().Utf8Value()]);
      }
      if ($colorBlend.Has("dstFactor")) {
        descriptor.colorBlend.dstFactor = static_cast<DawnBlendFactor>(GPUBlendFactor[$colorBlend.Get("dstFactor").As<Napi::String>().Utf8Value()]);
      }
    }
    if (value.Has("writeMask")) {
      descriptor.writeMask = static_cast<DawnColorWriteMask>(value.Get("writeMask").As<Napi::Number>().Uint32Value());
    }

    return descriptor;
  };
  
  DawnBufferCopyView GPUBufferCopyView(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnBufferCopyView descriptor;
    descriptor.nextInChain = nullptr;
    descriptor.offset = 0;
    {
      if (!(value.Get("buffer").As<Napi::Object>().InstanceOf(GPUBuffer::constructor.Value()))) {
        //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUBuffer' for 'GPUBufferCopyView'.'buffer'");
        return {};
      }
      descriptor.buffer = Napi::ObjectWrap<GPUBuffer>::Unwrap(value.Get("buffer").As<Napi::Object>())->instance;
    }
    if (value.Has("offset")) {
      bool lossless;
      descriptor.offset = value.Get("offset").As<Napi::BigInt>().Uint64Value(&lossless);
    }
    {
      descriptor.rowPitch = value.Get("rowPitch").As<Napi::Number>().Uint32Value();
    }
    {
      descriptor.imageHeight = value.Get("imageHeight").As<Napi::Number>().Uint32Value();
    }

    return descriptor;
  };
  
  DawnBufferDescriptor GPUBufferDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnBufferDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    {
      descriptor.usage = static_cast<DawnBufferUsage>(value.Get("usage").As<Napi::Number>().Uint32Value());
    }
    {
      bool lossless;
      descriptor.size = value.Get("size").As<Napi::BigInt>().Uint64Value(&lossless);
    }

    return descriptor;
  };
  
  DawnCreateBufferMappedResult GPUCreateBufferMappedResult(Napi::Object& device, Napi::Object& value) {

    DawnCreateBufferMappedResult descriptor;
    {
      if (!(value.Get("buffer").As<Napi::Object>().InstanceOf(GPUBuffer::constructor.Value()))) {
        //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUBuffer' for 'GPUCreateBufferMappedResult'.'buffer'");
        return {};
      }
      descriptor.buffer = Napi::ObjectWrap<GPUBuffer>::Unwrap(value.Get("buffer").As<Napi::Object>())->instance;
    }
    {
      bool lossless;
      descriptor.dataLength = value.Get("dataLength").As<Napi::BigInt>().Uint64Value(&lossless);
    }
    {
    }

    return descriptor;
  };
  
  DawnColor GPUColor(Napi::Object& device, Napi::Object& value) {

    DawnColor descriptor;
    {
      descriptor.r = value.Get("r").As<Napi::Number>().FloatValue();
    }
    {
      descriptor.g = value.Get("g").As<Napi::Number>().FloatValue();
    }
    {
      descriptor.b = value.Get("b").As<Napi::Number>().FloatValue();
    }
    {
      descriptor.a = value.Get("a").As<Napi::Number>().FloatValue();
    }

    return descriptor;
  };
  
  DawnCommandBufferDescriptor GPUCommandBufferDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnCommandBufferDescriptor descriptor;
    descriptor.nextInChain = nullptr;

    return descriptor;
  };
  
  DawnCommandEncoderDescriptor GPUCommandEncoderDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnCommandEncoderDescriptor descriptor;
    descriptor.nextInChain = nullptr;

    return descriptor;
  };
  
  DawnComputePassDescriptor GPUComputePassDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnComputePassDescriptor descriptor;
    descriptor.nextInChain = nullptr;

    return descriptor;
  };
  
  DawnComputePipelineDescriptor GPUComputePipelineDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnComputePipelineDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    {
      if (!(value.Get("layout").As<Napi::Object>().InstanceOf(GPUPipelineLayout::constructor.Value()))) {
        //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUPipelineLayout' for 'GPUComputePipelineDescriptor'.'layout'");
        return {};
      }
      descriptor.layout = Napi::ObjectWrap<GPUPipelineLayout>::Unwrap(value.Get("layout").As<Napi::Object>())->instance;
    }
    {
      Napi::Object $computeStage = value.Get("computeStage").As<Napi::Object>();
      {
        if (!($computeStage.Get("module").As<Napi::Object>().InstanceOf(GPUShaderModule::constructor.Value()))) {
          //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUShaderModule' for 'GPUPipelineStageDescriptor'.'module'");
          return {};
        }
        descriptor.computeStage.module = Napi::ObjectWrap<GPUShaderModule>::Unwrap($computeStage.Get("module").As<Napi::Object>())->instance;
      }
      {
        descriptor.computeStage.entryPoint = getNAPIStringCopy($computeStage.Get("entryPoint"));
      }
    }

    return descriptor;
  };
  
  DawnDepthStencilStateDescriptor GPUDepthStencilStateDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnDepthStencilStateDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    descriptor.depthWriteEnabled = false;
    descriptor.depthCompare = static_cast<DawnCompareFunction>(7);
    descriptor.stencilReadMask = 0xFFFFFFFF;
    descriptor.stencilWriteMask = 0xFFFFFFFF;
    {
      descriptor.format = static_cast<DawnTextureFormat>(GPUTextureFormat[value.Get("format").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("depthWriteEnabled")) {
      descriptor.depthWriteEnabled = value.Get("depthWriteEnabled").As<Napi::Boolean>().Value();
    }
    if (value.Has("depthCompare")) {
      descriptor.depthCompare = static_cast<DawnCompareFunction>(GPUCompareFunction[value.Get("depthCompare").As<Napi::String>().Utf8Value()]);
    }
    {
      Napi::Object $stencilFront = value.Get("stencilFront").As<Napi::Object>();
      if ($stencilFront.Has("compare")) {
        descriptor.stencilFront.compare = static_cast<DawnCompareFunction>(GPUCompareFunction[$stencilFront.Get("compare").As<Napi::String>().Utf8Value()]);
      }
      if ($stencilFront.Has("failOp")) {
        descriptor.stencilFront.failOp = static_cast<DawnStencilOperation>(GPUStencilOperation[$stencilFront.Get("failOp").As<Napi::String>().Utf8Value()]);
      }
      if ($stencilFront.Has("depthFailOp")) {
        descriptor.stencilFront.depthFailOp = static_cast<DawnStencilOperation>(GPUStencilOperation[$stencilFront.Get("depthFailOp").As<Napi::String>().Utf8Value()]);
      }
      if ($stencilFront.Has("passOp")) {
        descriptor.stencilFront.passOp = static_cast<DawnStencilOperation>(GPUStencilOperation[$stencilFront.Get("passOp").As<Napi::String>().Utf8Value()]);
      }
    }
    {
      Napi::Object $stencilBack = value.Get("stencilBack").As<Napi::Object>();
      if ($stencilBack.Has("compare")) {
        descriptor.stencilBack.compare = static_cast<DawnCompareFunction>(GPUCompareFunction[$stencilBack.Get("compare").As<Napi::String>().Utf8Value()]);
      }
      if ($stencilBack.Has("failOp")) {
        descriptor.stencilBack.failOp = static_cast<DawnStencilOperation>(GPUStencilOperation[$stencilBack.Get("failOp").As<Napi::String>().Utf8Value()]);
      }
      if ($stencilBack.Has("depthFailOp")) {
        descriptor.stencilBack.depthFailOp = static_cast<DawnStencilOperation>(GPUStencilOperation[$stencilBack.Get("depthFailOp").As<Napi::String>().Utf8Value()]);
      }
      if ($stencilBack.Has("passOp")) {
        descriptor.stencilBack.passOp = static_cast<DawnStencilOperation>(GPUStencilOperation[$stencilBack.Get("passOp").As<Napi::String>().Utf8Value()]);
      }
    }
    if (value.Has("stencilReadMask")) {
      descriptor.stencilReadMask = value.Get("stencilReadMask").As<Napi::Number>().Uint32Value();
    }
    if (value.Has("stencilWriteMask")) {
      descriptor.stencilWriteMask = value.Get("stencilWriteMask").As<Napi::Number>().Uint32Value();
    }

    return descriptor;
  };
  
  DawnExtent3D GPUExtent3D(Napi::Object& device, Napi::Object& value) {

    DawnExtent3D descriptor;
    {
      descriptor.width = value.Get("width").As<Napi::Number>().Uint32Value();
    }
    {
      descriptor.height = value.Get("height").As<Napi::Number>().Uint32Value();
    }
    {
      descriptor.depth = value.Get("depth").As<Napi::Number>().Uint32Value();
    }

    return descriptor;
  };
  
  DawnFenceDescriptor GPUFenceDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnFenceDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    descriptor.initialValue = 0;
    if (value.Has("initialValue")) {
      bool lossless;
      descriptor.initialValue = value.Get("initialValue").As<Napi::BigInt>().Uint64Value(&lossless);
    }

    return descriptor;
  };
  
  DawnVertexAttributeDescriptor GPUVertexAttributeDescriptor(Napi::Object& device, Napi::Object& value) {

    DawnVertexAttributeDescriptor descriptor;
    descriptor.offset = 0;
    {
      descriptor.shaderLocation = value.Get("shaderLocation").As<Napi::Number>().Uint32Value();
    }
    if (value.Has("offset")) {
      bool lossless;
      descriptor.offset = value.Get("offset").As<Napi::BigInt>().Uint64Value(&lossless);
    }
    {
      descriptor.format = static_cast<DawnVertexFormat>(GPUVertexFormat[value.Get("format").As<Napi::String>().Utf8Value()]);
    }

    return descriptor;
  };
  
  DawnVertexBufferDescriptor GPUVertexBufferDescriptor(Napi::Object& device, Napi::Object& value) {

    DawnVertexBufferDescriptor descriptor;
    descriptor.stepMode = static_cast<DawnInputStepMode>(0);
    {
      bool lossless;
      descriptor.stride = value.Get("stride").As<Napi::BigInt>().Uint64Value(&lossless);
    }
    if (value.Has("stepMode")) {
      descriptor.stepMode = static_cast<DawnInputStepMode>(GPUInputStepMode[value.Get("stepMode").As<Napi::String>().Utf8Value()]);
    }
    {
      descriptor.attributeCount = value.Get("attributeCount").As<Napi::Number>().Uint32Value();
    }
    {
      Napi::Array array = value.Get("attributes").As<Napi::Array>();
      uint32_t length = array.Length();
      std::vector<DawnVertexAttributeDescriptor> data;
      for (unsigned int ii = 0; ii < length; ++ii) {
        Napi::Object item = array.Get(ii).As<Napi::Object>();
        DawnVertexAttributeDescriptor $attributes;
        {
          $attributes.shaderLocation = item.Get("shaderLocation").As<Napi::Number>().Uint32Value();
        }
        if (item.Has("offset")) {
          bool lossless;
          $attributes.offset = item.Get("offset").As<Napi::BigInt>().Uint64Value(&lossless);
        }
        {
          $attributes.format = static_cast<DawnVertexFormat>(GPUVertexFormat[item.Get("format").As<Napi::String>().Utf8Value()]);
        }
        data.push_back($attributes);
      };
      descriptor.attributeCount = length;
      descriptor.attributes = data.data();
    }

    return descriptor;
  };
  
  DawnVertexInputDescriptor GPUVertexInputDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnVertexInputDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    descriptor.indexFormat = static_cast<DawnIndexFormat>(1);
    descriptor.bufferCount = 0;
    if (value.Has("indexFormat")) {
      descriptor.indexFormat = static_cast<DawnIndexFormat>(GPUIndexFormat[value.Get("indexFormat").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("bufferCount")) {
      descriptor.bufferCount = value.Get("bufferCount").As<Napi::Number>().Uint32Value();
    }
    {
      Napi::Array array = value.Get("buffers").As<Napi::Array>();
      uint32_t length = array.Length();
      std::vector<DawnVertexBufferDescriptor> data;
      for (unsigned int ii = 0; ii < length; ++ii) {
        Napi::Object item = array.Get(ii).As<Napi::Object>();
        DawnVertexBufferDescriptor $buffers;
        {
          bool lossless;
          $buffers.stride = item.Get("stride").As<Napi::BigInt>().Uint64Value(&lossless);
        }
        if (item.Has("stepMode")) {
          $buffers.stepMode = static_cast<DawnInputStepMode>(GPUInputStepMode[item.Get("stepMode").As<Napi::String>().Utf8Value()]);
        }
        {
          $buffers.attributeCount = item.Get("attributeCount").As<Napi::Number>().Uint32Value();
        }
        {
          Napi::Array array = item.Get("attributes").As<Napi::Array>();
          uint32_t length = array.Length();
          std::vector<DawnVertexAttributeDescriptor> data;
          for (unsigned int ii = 0; ii < length; ++ii) {
            Napi::Object item = array.Get(ii).As<Napi::Object>();
            DawnVertexAttributeDescriptor $attributes;
            {
              $attributes.shaderLocation = item.Get("shaderLocation").As<Napi::Number>().Uint32Value();
            }
            if (item.Has("offset")) {
              bool lossless;
              $attributes.offset = item.Get("offset").As<Napi::BigInt>().Uint64Value(&lossless);
            }
            {
              $attributes.format = static_cast<DawnVertexFormat>(GPUVertexFormat[item.Get("format").As<Napi::String>().Utf8Value()]);
            }
            data.push_back($attributes);
          };
          $buffers.attributeCount = length;
          $buffers.attributes = data.data();
        }
        data.push_back($buffers);
      };
      descriptor.bufferCount = length;
      descriptor.buffers = data.data();
    }

    return descriptor;
  };
  
  DawnOrigin3D GPUOrigin3D(Napi::Object& device, Napi::Object& value) {

    DawnOrigin3D descriptor;
    descriptor.x = 0;
    descriptor.y = 0;
    descriptor.z = 0;
    if (value.Has("x")) {
      descriptor.x = value.Get("x").As<Napi::Number>().Uint32Value();
    }
    if (value.Has("y")) {
      descriptor.y = value.Get("y").As<Napi::Number>().Uint32Value();
    }
    if (value.Has("z")) {
      descriptor.z = value.Get("z").As<Napi::Number>().Uint32Value();
    }

    return descriptor;
  };
  
  DawnPipelineLayoutDescriptor GPUPipelineLayoutDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnPipelineLayoutDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    {
      descriptor.bindGroupLayoutCount = value.Get("bindGroupLayoutCount").As<Napi::Number>().Uint32Value();
    }
    {
      // UNIMPLEMENTED
    }

    return descriptor;
  };
  
  DawnPipelineStageDescriptor GPUPipelineStageDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnPipelineStageDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    {
      if (!(value.Get("module").As<Napi::Object>().InstanceOf(GPUShaderModule::constructor.Value()))) {
        //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUShaderModule' for 'GPUPipelineStageDescriptor'.'module'");
        return {};
      }
      descriptor.module = Napi::ObjectWrap<GPUShaderModule>::Unwrap(value.Get("module").As<Napi::Object>())->instance;
    }
    {
      descriptor.entryPoint = getNAPIStringCopy(value.Get("entryPoint"));
    }

    return descriptor;
  };
  
  DawnRasterizationStateDescriptor GPURasterizationStateDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnRasterizationStateDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    descriptor.frontFace = static_cast<DawnFrontFace>(0);
    descriptor.cullMode = static_cast<DawnCullMode>(0);
    descriptor.depthBias = 0;
    descriptor.depthBiasSlopeScale = 0.0f;
    descriptor.depthBiasClamp = 0.0f;
    if (value.Has("frontFace")) {
      descriptor.frontFace = static_cast<DawnFrontFace>(GPUFrontFace[value.Get("frontFace").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("cullMode")) {
      descriptor.cullMode = static_cast<DawnCullMode>(GPUCullMode[value.Get("cullMode").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("depthBias")) {
      descriptor.depthBias = value.Get("depthBias").As<Napi::Number>().Int32Value();
    }
    if (value.Has("depthBiasSlopeScale")) {
      descriptor.depthBiasSlopeScale = value.Get("depthBiasSlopeScale").As<Napi::Number>().FloatValue();
    }
    if (value.Has("depthBiasClamp")) {
      descriptor.depthBiasClamp = value.Get("depthBiasClamp").As<Napi::Number>().FloatValue();
    }

    return descriptor;
  };
  
  DawnRenderBundleDescriptor GPURenderBundleDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnRenderBundleDescriptor descriptor;
    descriptor.nextInChain = nullptr;

    return descriptor;
  };
  
  DawnRenderBundleEncoderDescriptor GPURenderBundleEncoderDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnRenderBundleEncoderDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    descriptor.sampleCount = 1;
    {
      descriptor.colorFormatsCount = value.Get("colorFormatsCount").As<Napi::Number>().Uint32Value();
    }
    {
      // UNIMPLEMENTED
    }
    if (value.Has("depthStencilFormat")) {
      descriptor.depthStencilFormat = static_cast<DawnTextureFormat>(GPUTextureFormat[value.Get("depthStencilFormat").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("sampleCount")) {
      descriptor.sampleCount = value.Get("sampleCount").As<Napi::Number>().Uint32Value();
    }

    return descriptor;
  };
  
  DawnRenderPassColorAttachmentDescriptor GPURenderPassColorAttachmentDescriptor(Napi::Object& device, Napi::Object& value) {

    DawnRenderPassColorAttachmentDescriptor descriptor;
    {
      if (!(value.Get("attachment").As<Napi::Object>().InstanceOf(GPUTextureView::constructor.Value()))) {
        //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUTextureView' for 'GPURenderPassColorAttachmentDescriptor'.'attachment'");
        return {};
      }
      descriptor.attachment = Napi::ObjectWrap<GPUTextureView>::Unwrap(value.Get("attachment").As<Napi::Object>())->instance;
    }
    {
      if (!(value.Get("resolveTarget").As<Napi::Object>().InstanceOf(GPUTextureView::constructor.Value()))) {
        //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUTextureView' for 'GPURenderPassColorAttachmentDescriptor'.'resolveTarget'");
        return {};
      }
      descriptor.resolveTarget = Napi::ObjectWrap<GPUTextureView>::Unwrap(value.Get("resolveTarget").As<Napi::Object>())->instance;
    }
    {
      descriptor.loadOp = static_cast<DawnLoadOp>(GPULoadOp[value.Get("loadOp").As<Napi::String>().Utf8Value()]);
    }
    {
      descriptor.storeOp = static_cast<DawnStoreOp>(GPUStoreOp[value.Get("storeOp").As<Napi::String>().Utf8Value()]);
    }
    {
      Napi::Object $clearColor = value.Get("clearColor").As<Napi::Object>();
      {
        descriptor.clearColor.r = $clearColor.Get("r").As<Napi::Number>().FloatValue();
      }
      {
        descriptor.clearColor.g = $clearColor.Get("g").As<Napi::Number>().FloatValue();
      }
      {
        descriptor.clearColor.b = $clearColor.Get("b").As<Napi::Number>().FloatValue();
      }
      {
        descriptor.clearColor.a = $clearColor.Get("a").As<Napi::Number>().FloatValue();
      }
    }

    return descriptor;
  };
  
  DawnRenderPassDepthStencilAttachmentDescriptor GPURenderPassDepthStencilAttachmentDescriptor(Napi::Object& device, Napi::Object& value) {

    DawnRenderPassDepthStencilAttachmentDescriptor descriptor;
    descriptor.clearStencil = 0;
    {
      if (!(value.Get("attachment").As<Napi::Object>().InstanceOf(GPUTextureView::constructor.Value()))) {
        //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUTextureView' for 'GPURenderPassDepthStencilAttachmentDescriptor'.'attachment'");
        return {};
      }
      descriptor.attachment = Napi::ObjectWrap<GPUTextureView>::Unwrap(value.Get("attachment").As<Napi::Object>())->instance;
    }
    {
      descriptor.depthLoadOp = static_cast<DawnLoadOp>(GPULoadOp[value.Get("depthLoadOp").As<Napi::String>().Utf8Value()]);
    }
    {
      descriptor.depthStoreOp = static_cast<DawnStoreOp>(GPUStoreOp[value.Get("depthStoreOp").As<Napi::String>().Utf8Value()]);
    }
    {
      descriptor.clearDepth = value.Get("clearDepth").As<Napi::Number>().FloatValue();
    }
    {
      descriptor.stencilLoadOp = static_cast<DawnLoadOp>(GPULoadOp[value.Get("stencilLoadOp").As<Napi::String>().Utf8Value()]);
    }
    {
      descriptor.stencilStoreOp = static_cast<DawnStoreOp>(GPUStoreOp[value.Get("stencilStoreOp").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("clearStencil")) {
      descriptor.clearStencil = value.Get("clearStencil").As<Napi::Number>().Uint32Value();
    }

    return descriptor;
  };
  
  DawnRenderPassDescriptor GPURenderPassDescriptor(Napi::Object& device, Napi::Object& value) {

    DawnRenderPassDescriptor descriptor;
    {
      descriptor.colorAttachmentCount = value.Get("colorAttachmentCount").As<Napi::Number>().Uint32Value();
    }
    {
      Napi::Array array = value.Get("colorAttachments").As<Napi::Array>();
      uint32_t length = array.Length();
      std::vector<DawnRenderPassColorAttachmentDescriptor> data;
      for (unsigned int ii = 0; ii < length; ++ii) {
        Napi::Object item = array.Get(ii).As<Napi::Object>();
        DawnRenderPassColorAttachmentDescriptor $colorAttachments;
        {
          if (!(item.Get("attachment").As<Napi::Object>().InstanceOf(GPUTextureView::constructor.Value()))) {
            //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUTextureView' for 'GPURenderPassColorAttachmentDescriptor'.'attachment'");
            return {};
          }
          $colorAttachments.attachment = Napi::ObjectWrap<GPUTextureView>::Unwrap(item.Get("attachment").As<Napi::Object>())->instance;
        }
        {
          if (!(item.Get("resolveTarget").As<Napi::Object>().InstanceOf(GPUTextureView::constructor.Value()))) {
            //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUTextureView' for 'GPURenderPassColorAttachmentDescriptor'.'resolveTarget'");
            return {};
          }
          $colorAttachments.resolveTarget = Napi::ObjectWrap<GPUTextureView>::Unwrap(item.Get("resolveTarget").As<Napi::Object>())->instance;
        }
        {
          $colorAttachments.loadOp = static_cast<DawnLoadOp>(GPULoadOp[item.Get("loadOp").As<Napi::String>().Utf8Value()]);
        }
        {
          $colorAttachments.storeOp = static_cast<DawnStoreOp>(GPUStoreOp[item.Get("storeOp").As<Napi::String>().Utf8Value()]);
        }
        {
          Napi::Object $clearColor = item.Get("clearColor").As<Napi::Object>();
          {
            $colorAttachments.clearColor.r = $clearColor.Get("r").As<Napi::Number>().FloatValue();
          }
          {
            $colorAttachments.clearColor.g = $clearColor.Get("g").As<Napi::Number>().FloatValue();
          }
          {
            $colorAttachments.clearColor.b = $clearColor.Get("b").As<Napi::Number>().FloatValue();
          }
          {
            $colorAttachments.clearColor.a = $clearColor.Get("a").As<Napi::Number>().FloatValue();
          }
        }
        data.push_back($colorAttachments);
      };
      descriptor.colorAttachmentCount = length;
      std::vector<DawnRenderPassColorAttachmentDescriptor*> dst(length);
      std::transform(data.begin(), data.end(), dst.begin(), [](DawnRenderPassColorAttachmentDescriptor& d) { return &d; });
      descriptor.colorAttachments = dst.data();
    }
    {
      DawnRenderPassDepthStencilAttachmentDescriptor depthStencilAttachment;
      Napi::Object $depthStencilAttachment = value.Get("depthStencilAttachment").As<Napi::Object>();
      {
        if (!($depthStencilAttachment.Get("attachment").As<Napi::Object>().InstanceOf(GPUTextureView::constructor.Value()))) {
          //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUTextureView' for 'GPURenderPassDepthStencilAttachmentDescriptor'.'attachment'");
          return {};
        }
        depthStencilAttachment.attachment = Napi::ObjectWrap<GPUTextureView>::Unwrap($depthStencilAttachment.Get("attachment").As<Napi::Object>())->instance;
      }
      {
        depthStencilAttachment.depthLoadOp = static_cast<DawnLoadOp>(GPULoadOp[$depthStencilAttachment.Get("depthLoadOp").As<Napi::String>().Utf8Value()]);
      }
      {
        depthStencilAttachment.depthStoreOp = static_cast<DawnStoreOp>(GPUStoreOp[$depthStencilAttachment.Get("depthStoreOp").As<Napi::String>().Utf8Value()]);
      }
      {
        depthStencilAttachment.clearDepth = $depthStencilAttachment.Get("clearDepth").As<Napi::Number>().FloatValue();
      }
      {
        depthStencilAttachment.stencilLoadOp = static_cast<DawnLoadOp>(GPULoadOp[$depthStencilAttachment.Get("stencilLoadOp").As<Napi::String>().Utf8Value()]);
      }
      {
        depthStencilAttachment.stencilStoreOp = static_cast<DawnStoreOp>(GPUStoreOp[$depthStencilAttachment.Get("stencilStoreOp").As<Napi::String>().Utf8Value()]);
      }
      if ($depthStencilAttachment.Has("clearStencil")) {
        depthStencilAttachment.clearStencil = $depthStencilAttachment.Get("clearStencil").As<Napi::Number>().Uint32Value();
      }
      {
        descriptor.depthStencilAttachment = new DawnRenderPassDepthStencilAttachmentDescriptor;
        memcpy(const_cast<DawnRenderPassDepthStencilAttachmentDescriptor*>(descriptor.depthStencilAttachment), &depthStencilAttachment, sizeof(DawnRenderPassDepthStencilAttachmentDescriptor));
      }
    }

    return descriptor;
  };
  
  DawnRenderPipelineDescriptor GPURenderPipelineDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnRenderPipelineDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    descriptor.sampleCount = 1;
    descriptor.sampleMask = 0xFFFFFFFF;
    descriptor.alphaToCoverageEnabled = false;
    {
      if (!(value.Get("layout").As<Napi::Object>().InstanceOf(GPUPipelineLayout::constructor.Value()))) {
        //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUPipelineLayout' for 'GPURenderPipelineDescriptor'.'layout'");
        return {};
      }
      descriptor.layout = Napi::ObjectWrap<GPUPipelineLayout>::Unwrap(value.Get("layout").As<Napi::Object>())->instance;
    }
    {
      Napi::Object $vertexStage = value.Get("vertexStage").As<Napi::Object>();
      {
        if (!($vertexStage.Get("module").As<Napi::Object>().InstanceOf(GPUShaderModule::constructor.Value()))) {
          //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUShaderModule' for 'GPUPipelineStageDescriptor'.'module'");
          return {};
        }
        descriptor.vertexStage.module = Napi::ObjectWrap<GPUShaderModule>::Unwrap($vertexStage.Get("module").As<Napi::Object>())->instance;
      }
      {
        descriptor.vertexStage.entryPoint = getNAPIStringCopy($vertexStage.Get("entryPoint"));
      }
    }
    {
      DawnPipelineStageDescriptor fragmentStage;
      Napi::Object $fragmentStage = value.Get("fragmentStage").As<Napi::Object>();
      {
        if (!($fragmentStage.Get("module").As<Napi::Object>().InstanceOf(GPUShaderModule::constructor.Value()))) {
          //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUShaderModule' for 'GPUPipelineStageDescriptor'.'module'");
          return {};
        }
        fragmentStage.module = Napi::ObjectWrap<GPUShaderModule>::Unwrap($fragmentStage.Get("module").As<Napi::Object>())->instance;
      }
      {
        fragmentStage.entryPoint = getNAPIStringCopy($fragmentStage.Get("entryPoint"));
      }
      {
        descriptor.fragmentStage = new DawnPipelineStageDescriptor;
        memcpy(const_cast<DawnPipelineStageDescriptor*>(descriptor.fragmentStage), &fragmentStage, sizeof(DawnPipelineStageDescriptor));
      }
    }
    {
      DawnVertexInputDescriptor vertexInput;
      Napi::Object $vertexInput = value.Get("vertexInput").As<Napi::Object>();
      if ($vertexInput.Has("indexFormat")) {
        vertexInput.indexFormat = static_cast<DawnIndexFormat>(GPUIndexFormat[$vertexInput.Get("indexFormat").As<Napi::String>().Utf8Value()]);
      }
      if ($vertexInput.Has("bufferCount")) {
        vertexInput.bufferCount = $vertexInput.Get("bufferCount").As<Napi::Number>().Uint32Value();
      }
      {
        Napi::Array array = $vertexInput.Get("buffers").As<Napi::Array>();
        uint32_t length = array.Length();
        std::vector<DawnVertexBufferDescriptor> data;
        for (unsigned int ii = 0; ii < length; ++ii) {
          Napi::Object item = array.Get(ii).As<Napi::Object>();
          DawnVertexBufferDescriptor $buffers;
          {
            bool lossless;
            $buffers.stride = item.Get("stride").As<Napi::BigInt>().Uint64Value(&lossless);
          }
          if (item.Has("stepMode")) {
            $buffers.stepMode = static_cast<DawnInputStepMode>(GPUInputStepMode[item.Get("stepMode").As<Napi::String>().Utf8Value()]);
          }
          {
            $buffers.attributeCount = item.Get("attributeCount").As<Napi::Number>().Uint32Value();
          }
          {
            Napi::Array array = item.Get("attributes").As<Napi::Array>();
            uint32_t length = array.Length();
            std::vector<DawnVertexAttributeDescriptor> data;
            for (unsigned int ii = 0; ii < length; ++ii) {
              Napi::Object item = array.Get(ii).As<Napi::Object>();
              DawnVertexAttributeDescriptor $attributes;
              {
                $attributes.shaderLocation = item.Get("shaderLocation").As<Napi::Number>().Uint32Value();
              }
              if (item.Has("offset")) {
                bool lossless;
                $attributes.offset = item.Get("offset").As<Napi::BigInt>().Uint64Value(&lossless);
              }
              {
                $attributes.format = static_cast<DawnVertexFormat>(GPUVertexFormat[item.Get("format").As<Napi::String>().Utf8Value()]);
              }
              data.push_back($attributes);
            };
            $buffers.attributeCount = length;
            $buffers.attributes = data.data();
          }
          data.push_back($buffers);
        };
        vertexInput.bufferCount = length;
        vertexInput.buffers = data.data();
      }
      {
        descriptor.vertexInput = new DawnVertexInputDescriptor;
        memcpy(const_cast<DawnVertexInputDescriptor*>(descriptor.vertexInput), &vertexInput, sizeof(DawnVertexInputDescriptor));
      }
    }
    {
      descriptor.primitiveTopology = static_cast<DawnPrimitiveTopology>(GPUPrimitiveTopology[value.Get("primitiveTopology").As<Napi::String>().Utf8Value()]);
    }
    {
      DawnRasterizationStateDescriptor rasterizationState;
      Napi::Object $rasterizationState = value.Get("rasterizationState").As<Napi::Object>();
      if ($rasterizationState.Has("frontFace")) {
        rasterizationState.frontFace = static_cast<DawnFrontFace>(GPUFrontFace[$rasterizationState.Get("frontFace").As<Napi::String>().Utf8Value()]);
      }
      if ($rasterizationState.Has("cullMode")) {
        rasterizationState.cullMode = static_cast<DawnCullMode>(GPUCullMode[$rasterizationState.Get("cullMode").As<Napi::String>().Utf8Value()]);
      }
      if ($rasterizationState.Has("depthBias")) {
        rasterizationState.depthBias = $rasterizationState.Get("depthBias").As<Napi::Number>().Int32Value();
      }
      if ($rasterizationState.Has("depthBiasSlopeScale")) {
        rasterizationState.depthBiasSlopeScale = $rasterizationState.Get("depthBiasSlopeScale").As<Napi::Number>().FloatValue();
      }
      if ($rasterizationState.Has("depthBiasClamp")) {
        rasterizationState.depthBiasClamp = $rasterizationState.Get("depthBiasClamp").As<Napi::Number>().FloatValue();
      }
      {
        descriptor.rasterizationState = new DawnRasterizationStateDescriptor;
        memcpy(const_cast<DawnRasterizationStateDescriptor*>(descriptor.rasterizationState), &rasterizationState, sizeof(DawnRasterizationStateDescriptor));
      }
    }
    if (value.Has("sampleCount")) {
      descriptor.sampleCount = value.Get("sampleCount").As<Napi::Number>().Uint32Value();
    }
    {
      DawnDepthStencilStateDescriptor depthStencilState;
      Napi::Object $depthStencilState = value.Get("depthStencilState").As<Napi::Object>();
      {
        depthStencilState.format = static_cast<DawnTextureFormat>(GPUTextureFormat[$depthStencilState.Get("format").As<Napi::String>().Utf8Value()]);
      }
      if ($depthStencilState.Has("depthWriteEnabled")) {
        depthStencilState.depthWriteEnabled = $depthStencilState.Get("depthWriteEnabled").As<Napi::Boolean>().Value();
      }
      if ($depthStencilState.Has("depthCompare")) {
        depthStencilState.depthCompare = static_cast<DawnCompareFunction>(GPUCompareFunction[$depthStencilState.Get("depthCompare").As<Napi::String>().Utf8Value()]);
      }
      {
        Napi::Object $stencilFront = $depthStencilState.Get("stencilFront").As<Napi::Object>();
        if ($stencilFront.Has("compare")) {
          depthStencilState.stencilFront.compare = static_cast<DawnCompareFunction>(GPUCompareFunction[$stencilFront.Get("compare").As<Napi::String>().Utf8Value()]);
        }
        if ($stencilFront.Has("failOp")) {
          depthStencilState.stencilFront.failOp = static_cast<DawnStencilOperation>(GPUStencilOperation[$stencilFront.Get("failOp").As<Napi::String>().Utf8Value()]);
        }
        if ($stencilFront.Has("depthFailOp")) {
          depthStencilState.stencilFront.depthFailOp = static_cast<DawnStencilOperation>(GPUStencilOperation[$stencilFront.Get("depthFailOp").As<Napi::String>().Utf8Value()]);
        }
        if ($stencilFront.Has("passOp")) {
          depthStencilState.stencilFront.passOp = static_cast<DawnStencilOperation>(GPUStencilOperation[$stencilFront.Get("passOp").As<Napi::String>().Utf8Value()]);
        }
      }
      {
        Napi::Object $stencilBack = $depthStencilState.Get("stencilBack").As<Napi::Object>();
        if ($stencilBack.Has("compare")) {
          depthStencilState.stencilBack.compare = static_cast<DawnCompareFunction>(GPUCompareFunction[$stencilBack.Get("compare").As<Napi::String>().Utf8Value()]);
        }
        if ($stencilBack.Has("failOp")) {
          depthStencilState.stencilBack.failOp = static_cast<DawnStencilOperation>(GPUStencilOperation[$stencilBack.Get("failOp").As<Napi::String>().Utf8Value()]);
        }
        if ($stencilBack.Has("depthFailOp")) {
          depthStencilState.stencilBack.depthFailOp = static_cast<DawnStencilOperation>(GPUStencilOperation[$stencilBack.Get("depthFailOp").As<Napi::String>().Utf8Value()]);
        }
        if ($stencilBack.Has("passOp")) {
          depthStencilState.stencilBack.passOp = static_cast<DawnStencilOperation>(GPUStencilOperation[$stencilBack.Get("passOp").As<Napi::String>().Utf8Value()]);
        }
      }
      if ($depthStencilState.Has("stencilReadMask")) {
        depthStencilState.stencilReadMask = $depthStencilState.Get("stencilReadMask").As<Napi::Number>().Uint32Value();
      }
      if ($depthStencilState.Has("stencilWriteMask")) {
        depthStencilState.stencilWriteMask = $depthStencilState.Get("stencilWriteMask").As<Napi::Number>().Uint32Value();
      }
      {
        descriptor.depthStencilState = new DawnDepthStencilStateDescriptor;
        memcpy(const_cast<DawnDepthStencilStateDescriptor*>(descriptor.depthStencilState), &depthStencilState, sizeof(DawnDepthStencilStateDescriptor));
      }
    }
    {
      descriptor.colorStateCount = value.Get("colorStateCount").As<Napi::Number>().Uint32Value();
    }
    {
      Napi::Array array = value.Get("colorStates").As<Napi::Array>();
      uint32_t length = array.Length();
      std::vector<DawnColorStateDescriptor> data;
      for (unsigned int ii = 0; ii < length; ++ii) {
        Napi::Object item = array.Get(ii).As<Napi::Object>();
        DawnColorStateDescriptor $colorStates;
        {
          $colorStates.format = static_cast<DawnTextureFormat>(GPUTextureFormat[item.Get("format").As<Napi::String>().Utf8Value()]);
        }
        {
          Napi::Object $alphaBlend = item.Get("alphaBlend").As<Napi::Object>();
          if ($alphaBlend.Has("operation")) {
            $colorStates.alphaBlend.operation = static_cast<DawnBlendOperation>(GPUBlendOperation[$alphaBlend.Get("operation").As<Napi::String>().Utf8Value()]);
          }
          if ($alphaBlend.Has("srcFactor")) {
            $colorStates.alphaBlend.srcFactor = static_cast<DawnBlendFactor>(GPUBlendFactor[$alphaBlend.Get("srcFactor").As<Napi::String>().Utf8Value()]);
          }
          if ($alphaBlend.Has("dstFactor")) {
            $colorStates.alphaBlend.dstFactor = static_cast<DawnBlendFactor>(GPUBlendFactor[$alphaBlend.Get("dstFactor").As<Napi::String>().Utf8Value()]);
          }
        }
        {
          Napi::Object $colorBlend = item.Get("colorBlend").As<Napi::Object>();
          if ($colorBlend.Has("operation")) {
            $colorStates.colorBlend.operation = static_cast<DawnBlendOperation>(GPUBlendOperation[$colorBlend.Get("operation").As<Napi::String>().Utf8Value()]);
          }
          if ($colorBlend.Has("srcFactor")) {
            $colorStates.colorBlend.srcFactor = static_cast<DawnBlendFactor>(GPUBlendFactor[$colorBlend.Get("srcFactor").As<Napi::String>().Utf8Value()]);
          }
          if ($colorBlend.Has("dstFactor")) {
            $colorStates.colorBlend.dstFactor = static_cast<DawnBlendFactor>(GPUBlendFactor[$colorBlend.Get("dstFactor").As<Napi::String>().Utf8Value()]);
          }
        }
        if (item.Has("writeMask")) {
          $colorStates.writeMask = static_cast<DawnColorWriteMask>(item.Get("writeMask").As<Napi::Number>().Uint32Value());
        }
        data.push_back($colorStates);
      };
      descriptor.colorStateCount = length;
      std::vector<DawnColorStateDescriptor*> dst(length);
      std::transform(data.begin(), data.end(), dst.begin(), [](DawnColorStateDescriptor& d) { return &d; });
      descriptor.colorStates = dst.data();
    }
    if (value.Has("sampleMask")) {
      descriptor.sampleMask = value.Get("sampleMask").As<Napi::Number>().Uint32Value();
    }
    if (value.Has("alphaToCoverageEnabled")) {
      descriptor.alphaToCoverageEnabled = value.Get("alphaToCoverageEnabled").As<Napi::Boolean>().Value();
    }

    return descriptor;
  };
  
  DawnSamplerDescriptor GPUSamplerDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnSamplerDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    descriptor.addressModeU = static_cast<DawnAddressMode>(2);
    descriptor.addressModeV = static_cast<DawnAddressMode>(2);
    descriptor.addressModeW = static_cast<DawnAddressMode>(2);
    descriptor.magFilter = static_cast<DawnFilterMode>(0);
    descriptor.minFilter = static_cast<DawnFilterMode>(0);
    descriptor.mipmapFilter = static_cast<DawnFilterMode>(0);
    descriptor.lodMinClamp = 0.0f;
    descriptor.lodMaxClamp = 1000.0f;
    descriptor.compare = static_cast<DawnCompareFunction>(0);
    if (value.Has("addressModeU")) {
      descriptor.addressModeU = static_cast<DawnAddressMode>(GPUAddressMode[value.Get("addressModeU").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("addressModeV")) {
      descriptor.addressModeV = static_cast<DawnAddressMode>(GPUAddressMode[value.Get("addressModeV").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("addressModeW")) {
      descriptor.addressModeW = static_cast<DawnAddressMode>(GPUAddressMode[value.Get("addressModeW").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("magFilter")) {
      descriptor.magFilter = static_cast<DawnFilterMode>(GPUFilterMode[value.Get("magFilter").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("minFilter")) {
      descriptor.minFilter = static_cast<DawnFilterMode>(GPUFilterMode[value.Get("minFilter").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("mipmapFilter")) {
      descriptor.mipmapFilter = static_cast<DawnFilterMode>(GPUFilterMode[value.Get("mipmapFilter").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("lodMinClamp")) {
      descriptor.lodMinClamp = value.Get("lodMinClamp").As<Napi::Number>().FloatValue();
    }
    if (value.Has("lodMaxClamp")) {
      descriptor.lodMaxClamp = value.Get("lodMaxClamp").As<Napi::Number>().FloatValue();
    }
    if (value.Has("compare")) {
      descriptor.compare = static_cast<DawnCompareFunction>(GPUCompareFunction[value.Get("compare").As<Napi::String>().Utf8Value()]);
    }

    return descriptor;
  };
  
  DawnShaderModuleDescriptor GPUShaderModuleDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnShaderModuleDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    {
      descriptor.codeSize = value.Get("codeSize").As<Napi::Number>().Uint32Value();
    }
    {
    }

    return descriptor;
  };
  
  DawnStencilStateFaceDescriptor GPUStencilStateFaceDescriptor(Napi::Object& device, Napi::Object& value) {

    DawnStencilStateFaceDescriptor descriptor;
    descriptor.compare = static_cast<DawnCompareFunction>(7);
    descriptor.failOp = static_cast<DawnStencilOperation>(0);
    descriptor.depthFailOp = static_cast<DawnStencilOperation>(0);
    descriptor.passOp = static_cast<DawnStencilOperation>(0);
    if (value.Has("compare")) {
      descriptor.compare = static_cast<DawnCompareFunction>(GPUCompareFunction[value.Get("compare").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("failOp")) {
      descriptor.failOp = static_cast<DawnStencilOperation>(GPUStencilOperation[value.Get("failOp").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("depthFailOp")) {
      descriptor.depthFailOp = static_cast<DawnStencilOperation>(GPUStencilOperation[value.Get("depthFailOp").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("passOp")) {
      descriptor.passOp = static_cast<DawnStencilOperation>(GPUStencilOperation[value.Get("passOp").As<Napi::String>().Utf8Value()]);
    }

    return descriptor;
  };
  
  DawnSwapChainDescriptor GPUSwapChainDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnSwapChainDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    {
      bool lossless;
      descriptor.implementation = value.Get("implementation").As<Napi::BigInt>().Uint64Value(&lossless);
    }

    return descriptor;
  };
  
  DawnTextureCopyView GPUTextureCopyView(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnTextureCopyView descriptor;
    descriptor.nextInChain = nullptr;
    descriptor.mipLevel = 0;
    descriptor.arrayLayer = 0;
    {
      if (!(value.Get("texture").As<Napi::Object>().InstanceOf(GPUTexture::constructor.Value()))) {
        //NAPI_THROW_JS_CB_ERROR(device, "TypeError", "Expected type 'GPUTexture' for 'GPUTextureCopyView'.'texture'");
        return {};
      }
      descriptor.texture = Napi::ObjectWrap<GPUTexture>::Unwrap(value.Get("texture").As<Napi::Object>())->instance;
    }
    if (value.Has("mipLevel")) {
      descriptor.mipLevel = value.Get("mipLevel").As<Napi::Number>().Uint32Value();
    }
    if (value.Has("arrayLayer")) {
      descriptor.arrayLayer = value.Get("arrayLayer").As<Napi::Number>().Uint32Value();
    }
    {
      Napi::Object $origin = value.Get("origin").As<Napi::Object>();
      if ($origin.Has("x")) {
        descriptor.origin.x = $origin.Get("x").As<Napi::Number>().Uint32Value();
      }
      if ($origin.Has("y")) {
        descriptor.origin.y = $origin.Get("y").As<Napi::Number>().Uint32Value();
      }
      if ($origin.Has("z")) {
        descriptor.origin.z = $origin.Get("z").As<Napi::Number>().Uint32Value();
      }
    }

    return descriptor;
  };
  
  DawnTextureDescriptor GPUTextureDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnTextureDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    descriptor.dimension = static_cast<DawnTextureDimension>(1);
    descriptor.arrayLayerCount = 1;
    descriptor.mipLevelCount = 1;
    descriptor.sampleCount = 1;
    {
      descriptor.usage = static_cast<DawnTextureUsage>(value.Get("usage").As<Napi::Number>().Uint32Value());
    }
    if (value.Has("dimension")) {
      descriptor.dimension = static_cast<DawnTextureDimension>(GPUTextureDimension[value.Get("dimension").As<Napi::String>().Utf8Value()]);
    }
    {
      Napi::Object $size = value.Get("size").As<Napi::Object>();
      {
        descriptor.size.width = $size.Get("width").As<Napi::Number>().Uint32Value();
      }
      {
        descriptor.size.height = $size.Get("height").As<Napi::Number>().Uint32Value();
      }
      {
        descriptor.size.depth = $size.Get("depth").As<Napi::Number>().Uint32Value();
      }
    }
    if (value.Has("arrayLayerCount")) {
      descriptor.arrayLayerCount = value.Get("arrayLayerCount").As<Napi::Number>().Uint32Value();
    }
    {
      descriptor.format = static_cast<DawnTextureFormat>(GPUTextureFormat[value.Get("format").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("mipLevelCount")) {
      descriptor.mipLevelCount = value.Get("mipLevelCount").As<Napi::Number>().Uint32Value();
    }
    if (value.Has("sampleCount")) {
      descriptor.sampleCount = value.Get("sampleCount").As<Napi::Number>().Uint32Value();
    }

    return descriptor;
  };
  
  DawnTextureViewDescriptor GPUTextureViewDescriptor(Napi::Object& device, Napi::Object& value, void* nextInChain = nullptr) {

    DawnTextureViewDescriptor descriptor;
    descriptor.nextInChain = nullptr;
    descriptor.baseMipLevel = 0;
    descriptor.mipLevelCount = 0;
    descriptor.baseArrayLayer = 0;
    descriptor.arrayLayerCount = 0;
    descriptor.aspect = static_cast<DawnTextureAspect>(0);
    if (value.Has("format")) {
      descriptor.format = static_cast<DawnTextureFormat>(GPUTextureFormat[value.Get("format").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("dimension")) {
      descriptor.dimension = static_cast<DawnTextureViewDimension>(GPUTextureViewDimension[value.Get("dimension").As<Napi::String>().Utf8Value()]);
    }
    if (value.Has("baseMipLevel")) {
      descriptor.baseMipLevel = value.Get("baseMipLevel").As<Napi::Number>().Uint32Value();
    }
    if (value.Has("mipLevelCount")) {
      descriptor.mipLevelCount = value.Get("mipLevelCount").As<Napi::Number>().Uint32Value();
    }
    if (value.Has("baseArrayLayer")) {
      descriptor.baseArrayLayer = value.Get("baseArrayLayer").As<Napi::Number>().Uint32Value();
    }
    if (value.Has("arrayLayerCount")) {
      descriptor.arrayLayerCount = value.Get("arrayLayerCount").As<Napi::Number>().Uint32Value();
    }
    if (value.Has("aspect")) {
      descriptor.aspect = static_cast<DawnTextureAspect>(GPUTextureAspect[value.Get("aspect").As<Napi::String>().Utf8Value()]);
    }

    return descriptor;
  };
  
}

#endif
